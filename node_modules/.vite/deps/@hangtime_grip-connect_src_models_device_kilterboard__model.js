import {
  __publicField
} from "./chunk-KVCYZR2Q.js";

// node_modules/@hangtime/grip-connect/src/models/base.model.ts
var BaseModel = class {
  constructor(base) {
    __publicField(this, "id");
    __publicField(this, "createdAt");
    __publicField(this, "updatedAt");
    var _a;
    this.id = base.id ?? ((_a = globalThis.crypto) == null ? void 0 : _a.randomUUID());
    this.createdAt = base.createdAt;
    this.updatedAt = base.updatedAt;
  }
};

// node_modules/@hangtime/grip-connect/src/models/device.model.ts
var Device = class extends BaseModel {
  constructor(device) {
    super(device);
    /**
     * Filters to identify the device during Bluetooth scanning.
     * Used to match devices that meet specific criteria such as name, service UUIDs, etc.
     * @type {BluetoothLEScanFilter[]}
     * @public
     * @readonly
     */
    __publicField(this, "filters");
    /**
     * Array of services provided by the device.
     * Services represent functionalities that the device supports, such as weight measurement, battery information, or custom services.
     * @type {Service[]}
     * @public
     * @readonly
     */
    __publicField(this, "services");
    /**
     * Reference to the `BluetoothDevice` object representing this device.
     * This is the actual device object obtained from the Web Bluetooth API after a successful connection.
     * @type {BluetoothDevice | undefined}
     * @public
     */
    __publicField(this, "bluetooth");
    /**
     * Object representing the set of commands available for this device.
     * These commands allow communication with the device to perform various operations such as starting measurements, retrieving data, or calibrating the device.
     * @type {Commands}
     * @public
     * @readonly
     */
    __publicField(this, "commands");
    /**
     * The BluetoothRemoteGATTServer interface of the Web Bluetooth API represents a GATT Server on a remote device.
     * @type {BluetoothRemoteGATTServer | undefined}
     * @private
     */
    __publicField(this, "server");
    /**
     * The last message written to the device.
     * @type {string | Uint8Array | null}
     * @protected
     */
    __publicField(this, "writeLast", null);
    /**
     * Indicates whether the device is currently active.
     * @type {boolean}
     */
    __publicField(this, "isActive", false);
    /**
     * Configuration for threshold and duration.
     */
    __publicField(this, "activeConfig", {
      threshold: 2.5,
      duration: 1e3
    });
    /**
     * Maximum mass recorded from the device, initialized to "0".
     * @type {string}
     * @protected
     */
    __publicField(this, "massMax");
    /**
     * Average mass calculated from the device data, initialized to "0".
     * @type {string}
     * @protected
     */
    __publicField(this, "massAverage");
    /**
     * Total sum of all mass data points recorded from the device.
     * Used to calculate the average mass.
     * @type {number}
     * @protected
     */
    __publicField(this, "massTotalSum");
    /**
     * Number of data points received from the device.
     * Used to calculate the average mass.
     * @type {number}
     * @protected
     */
    __publicField(this, "dataPointCount");
    /**
     * Array of DownloadPacket entries.
     * This array holds packets that contain data downloaded from the device.
     * @type {DownloadPacket[]}
     * @protected
     */
    __publicField(this, "downloadPackets", []);
    // Initialize an empty array of DownloadPacket entries
    /**
     * Represents the current tare value for calibration.
     * @type {number}
     */
    __publicField(this, "tareCurrent", 0);
    /**
     * Indicates whether the tare calibration process is active.
     * @type {boolean}
     */
    __publicField(this, "tareActive", false);
    /**
     * Timestamp when the tare calibration process started.
     * @type {number | null}
     */
    __publicField(this, "tareStartTime", null);
    /**
     * Array holding the samples collected during tare calibration.
     * @type {number[]}
     */
    __publicField(this, "tareSamples", []);
    /**
     * Duration time for the tare calibration process.
     * @type {number}
     */
    __publicField(this, "tareDuration", 5e3);
    /**
     * Optional callback for handling write operations.
     * @callback NotifyCallback
     * @param {massObject} data - The data passed to the callback.
     * @type {NotifyCallback | undefined}
     * @protected
     */
    __publicField(this, "notifyCallback", (data) => console.log(data));
    /**
     * Optional callback for handling write operations.
     * @callback WriteCallback
     * @param {string} data - The data passed to the callback.
     * @type {WriteCallback | undefined}
     * @protected
     */
    __publicField(this, "writeCallback", (data) => console.log(data));
    /**
     * Optional callback for handling write operations.
     * @callback ActiveCallback
     * @param {string} data - The data passed to the callback.
     * @type {ActiveCallback | undefined}
     * @protected
     */
    __publicField(this, "activeCallback", (data) => console.log(data));
    /**
     * Event listener for handling the 'gattserverdisconnected' event.
     * This listener delegates the event to the `onDisconnected` method.
     *
     * @private
     * @type {(event: Event) => void}
     */
    __publicField(this, "onDisconnectedListener", (event) => this.onDisconnected(event));
    /**
     * A map that stores notification event listeners keyed by characteristic UUIDs.
     * This allows for proper addition and removal of event listeners associated with each characteristic.
     *
     * @private
     * @type {Map<string, EventListener>}
     */
    __publicField(this, "notificationListeners", /* @__PURE__ */ new Map());
    /**
     * Sets the callback function to be called when the activity status changes,
     * and optionally sets the configuration for threshold and duration.
     *
     * This function allows you to specify a callback that will be invoked whenever
     * the activity status changes, indicating whether the device is currently active.
     * It also allows optionally configuring the threshold and duration used to determine activity.
     *
     * @param {ActiveCallback} callback - The callback function to be set. This function
     *                                      receives a boolean value indicating the new activity status.
     * @param {object} [options] - Optional configuration object containing the threshold and duration.
     * @param {number} [options.threshold=2.5] - The threshold value for determining activity.
     * @param {number} [options.duration=1000] - The duration (in milliseconds) to monitor the input for activity.
     * @returns {void}
     * @public
     *
     * @example
     * device.active((isActive) => {
     *   console.log(`Device is ${isActive ? 'active' : 'inactive'}`);
     * }, { threshold: 3.0, duration: 1500 });
     */
    __publicField(this, "active", (callback, options) => {
      this.activeCallback = callback;
      this.activeConfig = {
        threshold: (options == null ? void 0 : options.threshold) ?? this.activeConfig.threshold,
        // Use new threshold if provided, else use default
        duration: (options == null ? void 0 : options.duration) ?? this.activeConfig.duration
        // Use new duration if provided, else use default
      };
    });
    /**
     * Checks if a dynamic value is active based on a threshold and duration.
     *
     * This function assesses whether a given dynamic value surpasses a specified threshold
     * and remains active for a specified duration. If the activity status changes from
     * the previous state, the callback function is called with the updated activity status.
     *
     * @param {number} input - The dynamic value to check for activity status.
     * @returns {Promise<void>} A promise that resolves once the activity check is complete.
     *
     * @example
     * await device.activityCheck(5.0);
     */
    __publicField(this, "activityCheck", (input) => {
      return new Promise((resolve) => {
        const startValue = input;
        const { threshold, duration } = this.activeConfig;
        setTimeout(() => {
          const activeNow = startValue > threshold;
          if (this.isActive !== activeNow) {
            this.isActive = activeNow;
            if (this.activeCallback) {
              this.activeCallback(activeNow);
            }
          }
          resolve();
        }, duration);
      });
    });
    /**
     * Connects to a Bluetooth device.
     * @param {Function} [onSuccess] - Optional callback function to execute on successful connection. Default logs success.
     * @param {Function} [onError] - Optional callback function to execute on error. Default logs the error.
     * @public
     *
     * @example
     * device.connect(
     *   () => console.log("Connected successfully"),
     *   (error) => console.error("Connection failed:", error)
     * );
     */
    __publicField(this, "connect", async (onSuccess = () => console.log("Connected successfully"), onError = (error) => console.error(error)) => {
      try {
        const deviceServices = this.getAllServiceUUIDs();
        const bluetooth = await this.getBluetooth();
        this.bluetooth = await bluetooth.requestDevice({
          filters: this.filters,
          optionalServices: deviceServices
        });
        if (!this.bluetooth.gatt) {
          throw new Error("GATT is not available on this device");
        }
        this.bluetooth.addEventListener("gattserverdisconnected", this.onDisconnectedListener);
        this.server = await this.bluetooth.gatt.connect();
        if (this.server.connected) {
          await this.onConnected(onSuccess);
        }
      } catch (error) {
        onError(error);
      }
    });
    /**
     * Disconnects the device if it is currently connected.
     * - Removes all notification listeners from the device's characteristics.
     * - Removes the 'gattserverdisconnected' event listener.
     * - Attempts to gracefully disconnect the device's GATT server.
     * - Resets relevant properties to their initial states.
     * @returns {void}
     * @public
     *
     * @example
     * device.disconnect();
     */
    __publicField(this, "disconnect", () => {
      var _a, _b, _c;
      if (this.isConnected()) {
        this.updateTimestamp();
        this.services.forEach((service) => {
          service.characteristics.forEach((char) => {
            if (char.characteristic && char.id === "rx") {
              char.characteristic.stopNotifications();
              const listener = this.notificationListeners.get(char.uuid);
              if (listener) {
                char.characteristic.removeEventListener("characteristicvaluechanged", listener);
                this.notificationListeners.delete(char.uuid);
              }
            }
          });
        });
        (_a = this.bluetooth) == null ? void 0 : _a.removeEventListener("gattserverdisconnected", this.onDisconnectedListener);
        (_c = (_b = this.bluetooth) == null ? void 0 : _b.gatt) == null ? void 0 : _c.disconnect();
        this.server = void 0;
        this.writeLast = null;
        this.isActive = false;
      }
    });
    /**
     * Converts the `downloadPackets` array into a CSV formatted string.
     * @returns {string} A CSV string representation of the `downloadPackets` data, with each packet on a new line.
     * @private
     *
     * @example
     * const csvData = device.downloadToCSV();
     * console.log(csvData);
     */
    __publicField(this, "downloadToCSV", () => {
      const packets = [...this.downloadPackets];
      if (packets.length === 0) {
        return "";
      }
      return packets.map(
        (packet) => [
          packet.received.toString(),
          packet.sampleNum.toString(),
          packet.battRaw.toString(),
          ...packet.samples.map(String),
          ...packet.masses.map(String)
        ].map((v) => v.replace(/"/g, '""')).map((v) => `"${v}"`).join(",")
      ).join("\r\n");
    });
    /**
     * Converts an array of DownloadPacket objects to a JSON string.
     * @returns {string} JSON string representation of the data.
     * @private
     *
     * @example
     * const jsonData = device.downloadToJSON();
     * console.log(jsonData);
     */
    __publicField(this, "downloadToJSON", () => {
      return JSON.stringify(this.downloadPackets, null, 2);
    });
    /**
     * Converts an array of DownloadPacket objects to an XML string.
     * @returns {string}  XML string representation of the data.
     * @private
     *
     * @example
     * const xmlData = device.downloadToXML();
     * console.log(xmlData);
     */
    __publicField(this, "downloadToXML", () => {
      const xmlPackets = this.downloadPackets.map((packet) => {
        const samples = packet.samples.map((sample) => `<sample>${sample}</sample>`).join("");
        const masses = packet.masses.map((mass) => `<mass>${mass}</mass>`).join("");
        return `
          <packet>
            <received>${packet.received}</received>
            <sampleNum>${packet.sampleNum}</sampleNum>
            <battRaw>${packet.battRaw}</battRaw>
            <samples>${samples}</samples>
            <masses>${masses}</masses>
          </packet>
        `;
      }).join("");
      return `<DownloadPackets>${xmlPackets}</DownloadPackets>`;
    });
    /**
     * Exports the data in the specified format (CSV, JSON, XML) with a filename format:
     * 'data-export-YYYY-MM-DD-HH-MM-SS.{format}'.
     *
     * @param {('csv' | 'json' | 'xml')} [format='csv'] - The format in which to download the data.
     * Defaults to 'csv'. Accepted values are 'csv', 'json', and 'xml'.
     *
     * @returns {Promise<void>} Resolves when the data has been downloaded/written
     * @public
     *
     * @example
     * await device.download('json');
     */
    __publicField(this, "download", async (format = "csv") => {
      let content = "";
      if (format === "csv") {
        content = this.downloadToCSV();
      } else if (format === "json") {
        content = this.downloadToJSON();
      } else if (format === "xml") {
        content = this.downloadToXML();
      }
      const now = /* @__PURE__ */ new Date();
      const date = now.toISOString().split("T")[0];
      const time = now.toTimeString().split(" ")[0].replace(/:/g, "-");
      const fileName = `data-export-${date}-${time}.${format}`;
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        const mimeTypes = {
          csv: "text/csv",
          json: "application/json",
          xml: "application/xml"
        };
        const blob = new Blob([content], { type: mimeTypes[format] });
        const url = globalThis.URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", fileName);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        globalThis.URL.revokeObjectURL(url);
      } else {
        const { writeFile } = await import("./promises-BEBUHVUU.js");
        await writeFile(fileName, content);
        console.log(`File saved as ${fileName}`);
      }
    });
    /**
     * Returns UUIDs of all services associated with the device.
     * @returns {string[]} Array of service UUIDs.
     * @protected
     *
     * @example
     * const serviceUUIDs = device.getAllServiceUUIDs();
     * console.log(serviceUUIDs);
     */
    __publicField(this, "getAllServiceUUIDs", () => {
      return this.services.filter((service) => service == null ? void 0 : service.uuid).map((service) => service.uuid);
    });
    /**
     * Retrieves the characteristic from the device's service.
     * @param {string} serviceId - The UUID of the service.
     * @param {string} characteristicId - The UUID of the characteristic.
     * @returns {BluetoothRemoteGATTCharacteristic | undefined} The characteristic, if found.
     * @protected
     *
     * @example
     * const characteristic = device.getCharacteristic('battery', 'level');
     * if (characteristic) {
     *   console.log('Characteristic found');
     * }
     */
    __publicField(this, "getCharacteristic", (serviceId, characteristicId) => {
      const boardService = this.services.find((service) => service.id === serviceId);
      if (boardService) {
        const boardCharacteristic = boardService.characteristics.find(
          (characteristic) => characteristic.id === characteristicId
        );
        if (boardCharacteristic) {
          return boardCharacteristic.characteristic;
        }
      }
      return void 0;
    });
    /**
     * Handles notifications received from a characteristic.
     * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.
     *
     * @example
     * device.handleNotifications(someCharacteristic);
     */
    __publicField(this, "handleNotifications", (characteristic) => {
      const value = characteristic.value;
      if (!value) return;
      this.updateTimestamp();
      console.log(value);
    });
    /**
     * Checks if a Bluetooth device is connected.
     * @returns {boolean} A boolean indicating whether the device is connected.
     * @public
     *
     * @example
     * if (device.isConnected()) {
     *   console.log('Device is connected');
     * } else {
     *   console.log('Device is not connected');
     * }
     */
    __publicField(this, "isConnected", () => {
      var _a;
      if (!(this == null ? void 0 : this.bluetooth)) {
        return false;
      }
      return !!((_a = this.bluetooth.gatt) == null ? void 0 : _a.connected);
    });
    /**
     * Sets the callback function to be called when notifications are received.
     * @param {NotifyCallback} callback - The callback function to be set.
     * @returns {void}
     * @public
     *
     * @example
     * device.notify((data) => {
     *   console.log('Received notification:', data);
     * });
     */
    __publicField(this, "notify", (callback) => {
      this.notifyCallback = callback;
    });
    /**
     * Handles the 'connected' event.
     * @param {Function} onSuccess - Callback function to execute on successful connection.
     * @public
     *
     * @example
     * device.onConnected(() => {
     *   console.log('Device connected successfully');
     * });
     */
    __publicField(this, "onConnected", async (onSuccess) => {
      this.updateTimestamp();
      if (!this.server) {
        throw new Error("GATT server is not available");
      }
      const services = await this.server.getPrimaryServices();
      if (!services || services.length === 0) {
        throw new Error("No services found");
      }
      for (const service of services) {
        const matchingService = this.services.find((boardService) => boardService.uuid === service.uuid);
        if (matchingService) {
          await new Promise((resolve) => setTimeout(resolve, 100));
          const characteristics = await service.getCharacteristics();
          for (const characteristic of matchingService.characteristics) {
            const matchingCharacteristic = characteristics.find((char) => char.uuid === characteristic.uuid);
            if (matchingCharacteristic) {
              const element = matchingService.characteristics.find((char) => char.uuid === matchingCharacteristic.uuid);
              if (element) {
                element.characteristic = matchingCharacteristic;
                if (element.id === "rx") {
                  matchingCharacteristic.startNotifications();
                  const listener = (event) => {
                    const target = event.target;
                    if (target && target.value) {
                      this.handleNotifications(target);
                    }
                  };
                  matchingCharacteristic.addEventListener("characteristicvaluechanged", listener);
                  this.notificationListeners.set(element.uuid, listener);
                }
              }
            } else {
              throw new Error(`Characteristic ${characteristic.uuid} not found in service ${service.uuid}`);
            }
          }
        }
      }
      onSuccess();
    });
    /**
     * Handles the 'disconnected' event.
     * @param {Event} event - The 'disconnected' event.
     * @public
     *
     * @example
     * device.onDisconnected(event);
     */
    __publicField(this, "onDisconnected", (event) => {
      console.warn(`Device ${event.target.name} is disconnected.`);
      this.disconnect();
    });
    /**
     * Reads the value of the specified characteristic from the device.
     * @param {string} serviceId - The service ID where the characteristic belongs.
     * @param {string} characteristicId - The characteristic ID to read from.
     * @param {number} [duration=0] - The duration to wait before resolving the promise, in milliseconds.
     * @returns {Promise<string | undefined>} A promise that resolves when the read operation is completed.
     * @public
     *
     * @example
     * const value = await device.read('battery', 'level', 1000);
     * console.log('Battery level:', value);
     */
    __publicField(this, "read", async (serviceId, characteristicId, duration = 0) => {
      if (!this.isConnected()) {
        return void 0;
      }
      const characteristic = this.getCharacteristic(serviceId, characteristicId);
      if (!characteristic) {
        throw new Error(`Characteristic "${characteristicId}" not found in service "${serviceId}"`);
      }
      this.updateTimestamp();
      let decodedValue;
      const decoder = new TextDecoder("utf-8");
      const value = await characteristic.readValue();
      if ((serviceId === "battery" || serviceId === "humidity" || serviceId === "temperature") && characteristicId === "level") {
        decodedValue = value.getUint8(0).toString();
      } else {
        decodedValue = decoder.decode(value);
      }
      if (duration > 0) {
        await new Promise((resolve) => setTimeout(resolve, duration));
      }
      return decodedValue;
    });
    /**
     * Updates the timestamp of the last device interaction.
     * This method sets the updatedAt property to the current date and time.
     * @protected
     *
     * @example
     * device.updateTimestamp();
     * console.log('Last updated:', device.updatedAt);
     */
    __publicField(this, "updateTimestamp", () => {
      this.updatedAt = /* @__PURE__ */ new Date();
    });
    /**
     * Writes a message to the specified characteristic of a Bluetooth device and optionally provides a callback to handle responses.
     * @param {string} serviceId - The service UUID of the Bluetooth device containing the target characteristic.
     * @param {string} characteristicId - The characteristic UUID where the message will be written.
     * @param {string | Uint8Array | undefined} message - The message to be written to the characteristic. It can be a string or a Uint8Array.
     * @param {number} [duration=0] - Optional. The time in milliseconds to wait before resolving the promise. Defaults to 0 for immediate resolution.
     * @param {WriteCallback} [callback=writeCallback] - Optional. A custom callback to handle the response after the write operation is successful.
     * @returns {Promise<void>} A promise that resolves once the write operation is complete.
     * @public
     * @throws {Error} Throws an error if the characteristic is undefined.
     *
     * @example
     * // Example usage of the write function with a custom callback
     * await Progressor.write("progressor", "tx", ProgressorCommands.GET_BATT_VLTG, 250, (data) => {
     *   console.log(`Battery voltage: ${data}`);
     * });
     */
    __publicField(this, "write", async (serviceId, characteristicId, message, duration = 0, callback = this.writeCallback) => {
      if (!this.isConnected() || message === void 0) {
        return Promise.resolve();
      }
      const characteristic = this.getCharacteristic(serviceId, characteristicId);
      if (!characteristic) {
        throw new Error(`Characteristic "${characteristicId}" not found in service "${serviceId}"`);
      }
      this.updateTimestamp();
      const valueToWrite = typeof message === "string" ? new TextEncoder().encode(message) : message;
      await characteristic.writeValue(valueToWrite);
      this.writeLast = message;
      this.writeCallback = callback;
      if (duration > 0) {
        await new Promise((resolve) => setTimeout(resolve, duration));
      }
    });
    this.filters = device.filters || [];
    this.services = device.services || [];
    this.commands = device.commands || {};
    this.bluetooth = device.bluetooth;
    this.massMax = "0";
    this.massAverage = "0";
    this.massTotalSum = 0;
    this.dataPointCount = 0;
    this.createdAt = /* @__PURE__ */ new Date();
    this.updatedAt = /* @__PURE__ */ new Date();
  }
  /**
   * Attempt to use ES module import rather than require.
   * This approach uses an async dynamic import for `webbluetooth`,
   * so we can fallback if `navigator.bluetooth` is unavailable.
   */
  async getBluetooth() {
    if (typeof navigator !== "undefined" && "bluetooth" in navigator) {
      return navigator.bluetooth;
    }
    const { bluetooth } = await import("./dist-X7KCSCB7.js");
    return bluetooth;
  }
  /**
   * Initiates the tare calibration process.
   * @param {number} duration - The duration time for tare calibration.
   * @returns {boolean} A boolean indicating whether the tare calibration was successful.
   * @public
   *
   * @example
   * const success = device.tare(5000);
   * if (success) {
   *   console.log('Tare calibration started');
   * } else {
   *   console.log('Tare calibration failed to start');
   * }
   */
  tare(duration = 5e3) {
    if (this.tareActive) return false;
    this.updateTimestamp();
    this.tareActive = true;
    this.tareDuration = duration;
    this.tareSamples = [];
    this.tareStartTime = Date.now();
    return true;
  }
  /**
   * Apply tare calibration to the provided sample.
   * @param {number} sample - The sample to calibrate.
   * @returns {number} The calibrated tare value.
   * @protected
   *
   * @example
   * const calibratedSample = device.applyTare(rawSample);
   * console.log('Calibrated sample:', calibratedSample);
   */
  applyTare(sample) {
    if (this.tareActive && this.tareStartTime) {
      this.tareSamples.push(sample);
      if (Date.now() - this.tareStartTime >= this.tareDuration) {
        const total = this.tareSamples.reduce((acc, sample2) => acc + sample2, 0);
        this.tareCurrent = total / this.tareSamples.length;
        this.tareActive = false;
        this.tareStartTime = null;
        this.tareSamples = [];
      }
    }
    return this.tareCurrent;
  }
};

// node_modules/@hangtime/grip-connect/src/models/device/kilterboard.model.ts
var KilterBoardPacket = /* @__PURE__ */ ((KilterBoardPacket2) => {
  KilterBoardPacket2[KilterBoardPacket2["V2_MIDDLE"] = 77] = "V2_MIDDLE";
  KilterBoardPacket2[KilterBoardPacket2["V2_FIRST"] = 78] = "V2_FIRST";
  KilterBoardPacket2[KilterBoardPacket2["V2_LAST"] = 79] = "V2_LAST";
  KilterBoardPacket2[KilterBoardPacket2["V2_ONLY"] = 80] = "V2_ONLY";
  KilterBoardPacket2[KilterBoardPacket2["V3_MIDDLE"] = 81] = "V3_MIDDLE";
  KilterBoardPacket2[KilterBoardPacket2["V3_FIRST"] = 82] = "V3_FIRST";
  KilterBoardPacket2[KilterBoardPacket2["V3_LAST"] = 83] = "V3_LAST";
  KilterBoardPacket2[KilterBoardPacket2["V3_ONLY"] = 84] = "V3_ONLY";
  return KilterBoardPacket2;
})(KilterBoardPacket || {});
var KilterBoardPlacementRoles = [
  {
    id: 12,
    product_id: 1,
    position: 1,
    name: "start",
    full_name: "Start",
    led_color: "00FF00",
    screen_color: "00DD00"
  },
  {
    id: 13,
    product_id: 1,
    position: 2,
    name: "middle",
    full_name: "Middle",
    led_color: "00FFFF",
    screen_color: "00FFFF"
  },
  {
    id: 14,
    product_id: 1,
    position: 3,
    name: "finish",
    full_name: "Finish",
    led_color: "FF00FF",
    screen_color: "FF00FF"
  },
  {
    id: 15,
    product_id: 1,
    position: 4,
    name: "foot",
    full_name: "Foot Only",
    led_color: "FFB600",
    screen_color: "FFA500"
  }
];
var _KilterBoard = class _KilterBoard extends Device {
  constructor() {
    super({
      filters: [
        {
          services: [_KilterBoard.AuroraUUID]
        }
      ],
      services: [
        {
          name: "UART Nordic Service",
          id: "uart",
          uuid: "6e400001-b5a3-f393-e0a9-e50e24dcca9e",
          characteristics: [
            {
              name: "TX",
              id: "tx",
              uuid: "6e400002-b5a3-f393-e0a9-e50e24dcca9e"
            }
            // {
            //   name: "RX",
            //   id: "rx",
            //   uuid: "6e400003-b5a3-f393-e0a9-e50e24dcca9e",
            // },
          ]
        }
      ]
    });
    /**
     * The kilter board only supports messages of 20 bytes
     * at a time. This method splits a full message into parts
     * of 20 bytes
     *
     * @param buffer
     */
    __publicField(this, "splitMessages", (buffer) => this.splitEvery(_KilterBoard.maxBluetoothMessageSize, buffer).map((arr) => new Uint8Array(arr)));
    /**
     * Configures the LEDs based on an array of climb placements.
     * @param {{ position: number; role_id: number }[]} config - Array of climb placements for the LEDs.
     * @returns {Promise<number[] | undefined>} A promise that resolves with the payload array for the Kilter Board if LED settings were applied, or `undefined` if no action was taken or for the Motherboard.
     */
    __publicField(this, "led", async (config) => {
      if (Array.isArray(config)) {
        const payload = this.prepBytesV3(config);
        if (this.isConnected()) {
          await this.writeMessageSeries(this.splitMessages(payload));
        }
        return payload;
      }
      return void 0;
    });
  }
  /**
   * Calculates the checksum for a byte array by summing up all bytes ot hre packet in a single-byte variable.
   * @param data - The array of bytes to calculate the checksum for.
   * @returns {number} The calculated checksum value.
   */
  checksum(data) {
    let i = 0;
    for (const value of data) {
      i = i + value & 255;
    }
    return ~i & 255;
  }
  /**
   * Wraps a byte array with header and footer bytes for transmission.
   * @param data - The array of bytes to wrap.
   * @returns {number[]} The wrapped byte array.
   */
  wrapBytes(data) {
    if (data.length > _KilterBoard.messageBodyMaxLength) {
      return [];
    }
    return [1, data.length, this.checksum(data), 2, ...data, 3];
  }
  /**
   * Encodes a position into a byte array.
   * The lowest 8 bits of the position get put in the first byte of the group.
   * The highest 8 bits of the position get put in the second byte of the group.
   * @param position - The position to encode.
   * @returns {number[]} The encoded byte array representing the position.
   */
  encodePosition(position) {
    const position1 = position & 255;
    const position2 = (position & 65280) >> 8;
    return [position1, position2];
  }
  /**
   * Encodes a color string into a numeric representation.
   * The rgb color, 3 bits for the R and G components, 2 bits for the B component, with the 3 R bits occupying the high end of the byte and the 2 B bits in the low end (hence 3 G bits in the middle).
   * @param color - The color string in hexadecimal format (e.g., 'FFFFFF').
   * @returns The encoded /compressed color value.
   */
  encodeColor(color) {
    const substring = color.substring(0, 2);
    const substring2 = color.substring(2, 4);
    const parsedSubstring = parseInt(substring, 16) / 32;
    const parsedSubstring2 = parseInt(substring2, 16) / 32;
    const parsedResult = parsedSubstring << 5 | parsedSubstring2 << 2;
    const substring3 = color.substring(4, 6);
    const parsedSubstring3 = parseInt(substring3, 16) / 64;
    const finalParsedResult = parsedResult | parsedSubstring3;
    return finalParsedResult;
  }
  /**
   * Encodes a placement (requires a 16-bit position and a 24-bit rgb color. ) into a byte array.
   * @param position - The position to encode.
   * @param ledColor - The color of the LED in hexadecimal format (e.g., 'FFFFFF').
   * @returns The encoded byte array representing the placement.
   */
  encodePlacement(position, ledColor) {
    return [...this.encodePosition(position), this.encodeColor(ledColor)];
  }
  /**
   * Prepares byte arrays for transmission based on a list of climb placements.
   * @param {{ position: number; role_id: number }[]} climbPlacementList - The list of climb placements containing position and role ID.
   * @returns {number[]} The final byte array ready for transmission.
   */
  prepBytesV3(climbPlacementList) {
    const resultArray = [];
    let tempArray = [81 /* V3_MIDDLE */];
    for (const climbPlacement of climbPlacementList) {
      if (tempArray.length + 3 > _KilterBoard.messageBodyMaxLength) {
        resultArray.push(tempArray);
        tempArray = [81 /* V3_MIDDLE */];
      }
      const role = KilterBoardPlacementRoles.find((placement) => placement.id === climbPlacement.role_id);
      if (!role) {
        throw new Error(`Role with id ${climbPlacement.role_id} not found in placement_roles`);
      }
      const encodedPlacement = this.encodePlacement(climbPlacement.position, role.led_color);
      tempArray.push(...encodedPlacement);
    }
    resultArray.push(tempArray);
    if (resultArray.length === 1) {
      resultArray[0][0] = 84 /* V3_ONLY */;
    } else if (resultArray.length > 1) {
      resultArray[0][0] = 82 /* V3_FIRST */;
      resultArray[resultArray.length - 1][0] = 83 /* V3_LAST */;
    }
    const finalResultArray = [];
    for (const currentArray of resultArray) {
      finalResultArray.push(...this.wrapBytes(currentArray));
    }
    return finalResultArray;
  }
  /**
   * Splits a collection into slices of the specified length.
   * https://github.com/ramda/ramda/blob/master/source/splitEvery.js
   * @param {Number} n
   * @param {Array} list
   * @return {Array<number[]>}
   */
  splitEvery(n, list) {
    if (n <= 0) {
      throw new Error("First argument to splitEvery must be a positive integer");
    }
    const result = [];
    let idx = 0;
    while (idx < list.length) {
      result.push(list.slice(idx, idx += n));
    }
    return result;
  }
  /**
   * Sends a series of messages to a device.
   */
  async writeMessageSeries(messages) {
    for (const message of messages) {
      await this.write("uart", "tx", message);
    }
  }
};
/**
 * UUID for the Aurora Climbing Advertising service.
 * This constant is used to identify the specific Bluetooth service for Kilter Boards.
 * @type {string}
 * @static
 * @readonly
 * @constant
 */
__publicField(_KilterBoard, "AuroraUUID", "4488b571-7806-4df6-bcff-a2897e4953ff");
/**
 * Maximum length of the message body for byte wrapping.
 * This value defines the limit for the size of messages that can be sent or received
 * to ensure proper byte wrapping in communication.
 * @type {number}
 * @private
 * @readonly
 * @constant
 */
__publicField(_KilterBoard, "messageBodyMaxLength", 255);
/**
 * Maximum length of the Bluetooth message chunk.
 * This value sets the upper limit for the size of individual Bluetooth messages
 * sent to and from the device to comply with Bluetooth protocol constraints.
 * @type {number}
 * @private
 * @readonly
 * @constant
 */
__publicField(_KilterBoard, "maxBluetoothMessageSize", 20);
var KilterBoard = _KilterBoard;
export {
  KilterBoard,
  KilterBoardPacket,
  KilterBoardPlacementRoles
};
//# sourceMappingURL=@hangtime_grip-connect_src_models_device_kilterboard__model.js.map
