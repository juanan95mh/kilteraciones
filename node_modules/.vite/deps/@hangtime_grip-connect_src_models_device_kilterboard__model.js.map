{
  "version": 3,
  "sources": ["../../@hangtime/grip-connect/src/models/base.model.ts", "../../@hangtime/grip-connect/src/models/device.model.ts", "../../@hangtime/grip-connect/src/models/device/kilterboard.model.ts"],
  "sourcesContent": ["import type { IBase } from \"../interfaces/base.interface.js\"\n\nexport abstract class BaseModel {\n  id?: string\n\n  createdAt?: Date\n\n  updatedAt?: Date\n\n  constructor(base: IBase) {\n    this.id = base.id ?? globalThis.crypto?.randomUUID()\n\n    this.createdAt = base.createdAt\n    this.updatedAt = base.updatedAt\n  }\n}\n", "import { BaseModel } from \"./../models/base.model.js\"\nimport type { IDevice, Service } from \"../interfaces/device.interface.js\"\nimport type { ActiveCallback, massObject, NotifyCallback, WriteCallback } from \"../interfaces/callback.interface.js\"\nimport type { DownloadPacket } from \"../interfaces/download.interface.js\"\nimport type { Commands } from \"../interfaces/command.interface.js\"\n\nexport abstract class Device extends BaseModel implements IDevice {\n  /**\n   * Filters to identify the device during Bluetooth scanning.\n   * Used to match devices that meet specific criteria such as name, service UUIDs, etc.\n   * @type {BluetoothLEScanFilter[]}\n   * @public\n   * @readonly\n   */\n  readonly filters: BluetoothLEScanFilter[]\n\n  /**\n   * Array of services provided by the device.\n   * Services represent functionalities that the device supports, such as weight measurement, battery information, or custom services.\n   * @type {Service[]}\n   * @public\n   * @readonly\n   */\n  readonly services: Service[]\n\n  /**\n   * Reference to the `BluetoothDevice` object representing this device.\n   * This is the actual device object obtained from the Web Bluetooth API after a successful connection.\n   * @type {BluetoothDevice | undefined}\n   * @public\n   */\n  bluetooth?: BluetoothDevice | undefined\n\n  /**\n   * Object representing the set of commands available for this device.\n   * These commands allow communication with the device to perform various operations such as starting measurements, retrieving data, or calibrating the device.\n   * @type {Commands}\n   * @public\n   * @readonly\n   */\n  readonly commands: Commands\n\n  /**\n   * The BluetoothRemoteGATTServer interface of the Web Bluetooth API represents a GATT Server on a remote device.\n   * @type {BluetoothRemoteGATTServer | undefined}\n   * @private\n   */\n  private server: BluetoothRemoteGATTServer | undefined\n\n  /**\n   * The last message written to the device.\n   * @type {string | Uint8Array | null}\n   * @protected\n   */\n  protected writeLast: string | Uint8Array | null = null\n  /**\n   * Indicates whether the device is currently active.\n   * @type {boolean}\n   */\n  protected isActive = false\n  /**\n   * Configuration for threshold and duration.\n   */\n  private activeConfig: { threshold: number; duration: number } = {\n    threshold: 2.5,\n    duration: 1000,\n  }\n\n  /**\n   * Maximum mass recorded from the device, initialized to \"0\".\n   * @type {string}\n   * @protected\n   */\n  protected massMax: string\n\n  /**\n   * Average mass calculated from the device data, initialized to \"0\".\n   * @type {string}\n   * @protected\n   */\n  protected massAverage: string\n\n  /**\n   * Total sum of all mass data points recorded from the device.\n   * Used to calculate the average mass.\n   * @type {number}\n   * @protected\n   */\n  protected massTotalSum: number\n\n  /**\n   * Number of data points received from the device.\n   * Used to calculate the average mass.\n   * @type {number}\n   * @protected\n   */\n  protected dataPointCount: number\n\n  /**\n   * Array of DownloadPacket entries.\n   * This array holds packets that contain data downloaded from the device.\n   * @type {DownloadPacket[]}\n   * @protected\n   */\n  protected downloadPackets: DownloadPacket[] = [] // Initialize an empty array of DownloadPacket entries\n\n  /**\n   * Represents the current tare value for calibration.\n   * @type {number}\n   */\n  private tareCurrent = 0\n\n  /**\n   * Indicates whether the tare calibration process is active.\n   * @type {boolean}\n   */\n  private tareActive = false\n\n  /**\n   * Timestamp when the tare calibration process started.\n   * @type {number | null}\n   */\n  private tareStartTime: number | null = null\n\n  /**\n   * Array holding the samples collected during tare calibration.\n   * @type {number[]}\n   */\n  private tareSamples: number[] = []\n\n  /**\n   * Duration time for the tare calibration process.\n   * @type {number}\n   */\n  private tareDuration = 5000\n\n  /**\n   * Optional callback for handling write operations.\n   * @callback NotifyCallback\n   * @param {massObject} data - The data passed to the callback.\n   * @type {NotifyCallback | undefined}\n   * @protected\n   */\n  protected notifyCallback: NotifyCallback = (data: massObject) => console.log(data)\n\n  /**\n   * Optional callback for handling write operations.\n   * @callback WriteCallback\n   * @param {string} data - The data passed to the callback.\n   * @type {WriteCallback | undefined}\n   * @protected\n   */\n  protected writeCallback: WriteCallback = (data: string) => console.log(data)\n\n  /**\n   * Optional callback for handling write operations.\n   * @callback ActiveCallback\n   * @param {string} data - The data passed to the callback.\n   * @type {ActiveCallback | undefined}\n   * @protected\n   */\n  protected activeCallback: ActiveCallback = (data: boolean) => console.log(data)\n\n  /**\n   * Event listener for handling the 'gattserverdisconnected' event.\n   * This listener delegates the event to the `onDisconnected` method.\n   *\n   * @private\n   * @type {(event: Event) => void}\n   */\n  private onDisconnectedListener = (event: Event) => this.onDisconnected(event)\n\n  /**\n   * A map that stores notification event listeners keyed by characteristic UUIDs.\n   * This allows for proper addition and removal of event listeners associated with each characteristic.\n   *\n   * @private\n   * @type {Map<string, EventListener>}\n   */\n  private notificationListeners = new Map<string, EventListener>()\n\n  constructor(device: Partial<IDevice>) {\n    super(device)\n\n    this.filters = device.filters || []\n    this.services = device.services || []\n    this.commands = device.commands || {}\n    this.bluetooth = device.bluetooth\n\n    this.massMax = \"0\"\n    this.massAverage = \"0\"\n    this.massTotalSum = 0\n    this.dataPointCount = 0\n\n    this.createdAt = new Date()\n    this.updatedAt = new Date()\n  }\n\n  /**\n   * Sets the callback function to be called when the activity status changes,\n   * and optionally sets the configuration for threshold and duration.\n   *\n   * This function allows you to specify a callback that will be invoked whenever\n   * the activity status changes, indicating whether the device is currently active.\n   * It also allows optionally configuring the threshold and duration used to determine activity.\n   *\n   * @param {ActiveCallback} callback - The callback function to be set. This function\n   *                                      receives a boolean value indicating the new activity status.\n   * @param {object} [options] - Optional configuration object containing the threshold and duration.\n   * @param {number} [options.threshold=2.5] - The threshold value for determining activity.\n   * @param {number} [options.duration=1000] - The duration (in milliseconds) to monitor the input for activity.\n   * @returns {void}\n   * @public\n   *\n   * @example\n   * device.active((isActive) => {\n   *   console.log(`Device is ${isActive ? 'active' : 'inactive'}`);\n   * }, { threshold: 3.0, duration: 1500 });\n   */\n  active = (callback: ActiveCallback, options?: { threshold?: number; duration?: number }): void => {\n    this.activeCallback = callback\n\n    // Update the config values only if provided, otherwise use defaults\n    this.activeConfig = {\n      threshold: options?.threshold ?? this.activeConfig.threshold, // Use new threshold if provided, else use default\n      duration: options?.duration ?? this.activeConfig.duration, // Use new duration if provided, else use default\n    }\n  }\n\n  /**\n   * Checks if a dynamic value is active based on a threshold and duration.\n   *\n   * This function assesses whether a given dynamic value surpasses a specified threshold\n   * and remains active for a specified duration. If the activity status changes from\n   * the previous state, the callback function is called with the updated activity status.\n   *\n   * @param {number} input - The dynamic value to check for activity status.\n   * @returns {Promise<void>} A promise that resolves once the activity check is complete.\n   *\n   * @example\n   * await device.activityCheck(5.0);\n   */\n  protected activityCheck = (input: number): Promise<void> => {\n    return new Promise((resolve) => {\n      const startValue = input\n      const { threshold, duration } = this.activeConfig\n      setTimeout(() => {\n        // After waiting for `duration`, check if still active (for a real scenario, you might store a last known input)\n        const activeNow = startValue > threshold\n        if (this.isActive !== activeNow) {\n          this.isActive = activeNow\n          if (this.activeCallback) {\n            this.activeCallback(activeNow)\n          }\n        }\n        resolve()\n      }, duration)\n    })\n  }\n\n  /**\n   * Connects to a Bluetooth device.\n   * @param {Function} [onSuccess] - Optional callback function to execute on successful connection. Default logs success.\n   * @param {Function} [onError] - Optional callback function to execute on error. Default logs the error.\n   * @public\n   *\n   * @example\n   * device.connect(\n   *   () => console.log(\"Connected successfully\"),\n   *   (error) => console.error(\"Connection failed:\", error)\n   * );\n   */\n  connect = async (\n    onSuccess: () => void = () => console.log(\"Connected successfully\"),\n    onError: (error: Error) => void = (error) => console.error(error),\n  ): Promise<void> => {\n    try {\n      // Request device and set up connection\n      const deviceServices = this.getAllServiceUUIDs()\n\n      const bluetooth = await this.getBluetooth()\n\n      this.bluetooth = await bluetooth.requestDevice({\n        filters: this.filters,\n        optionalServices: deviceServices,\n      })\n\n      if (!this.bluetooth.gatt) {\n        throw new Error(\"GATT is not available on this device\")\n      }\n\n      this.bluetooth.addEventListener(\"gattserverdisconnected\", this.onDisconnectedListener)\n\n      this.server = await this.bluetooth.gatt.connect()\n\n      if (this.server.connected) {\n        await this.onConnected(onSuccess)\n      }\n    } catch (error) {\n      onError(error as Error)\n    }\n  }\n\n  /**\n   * Disconnects the device if it is currently connected.\n   * - Removes all notification listeners from the device's characteristics.\n   * - Removes the 'gattserverdisconnected' event listener.\n   * - Attempts to gracefully disconnect the device's GATT server.\n   * - Resets relevant properties to their initial states.\n   * @returns {void}\n   * @public\n   *\n   * @example\n   * device.disconnect();\n   */\n  disconnect = (): void => {\n    if (this.isConnected()) {\n      this.updateTimestamp()\n      // Remove all notification listeners\n      this.services.forEach((service) => {\n        service.characteristics.forEach((char) => {\n          // TODO: remove device-specific logic\n          if (char.characteristic && char.id === \"rx\") {\n            char.characteristic.stopNotifications()\n            const listener = this.notificationListeners.get(char.uuid)\n            if (listener) {\n              char.characteristic.removeEventListener(\"characteristicvaluechanged\", listener)\n              this.notificationListeners.delete(char.uuid)\n            }\n          }\n        })\n      })\n      // Remove disconnect listener\n      this.bluetooth?.removeEventListener(\"gattserverdisconnected\", this.onDisconnectedListener)\n      // Safely attempt to disconnect the device's GATT server, if available\n      this.bluetooth?.gatt?.disconnect()\n      // Reset properties\n      this.server = undefined\n      this.writeLast = null\n      this.isActive = false\n    }\n  }\n\n  /**\n   * Converts the `downloadPackets` array into a CSV formatted string.\n   * @returns {string} A CSV string representation of the `downloadPackets` data, with each packet on a new line.\n   * @private\n   *\n   * @example\n   * const csvData = device.downloadToCSV();\n   * console.log(csvData);\n   */\n  private downloadToCSV = (): string => {\n    const packets = [...this.downloadPackets]\n    if (packets.length === 0) {\n      return \"\"\n    }\n    return packets\n      .map((packet) =>\n        [\n          packet.received.toString(),\n          packet.sampleNum.toString(),\n          packet.battRaw.toString(),\n          ...packet.samples.map(String),\n          ...packet.masses.map(String),\n        ]\n          .map((v) => v.replace(/\"/g, '\"\"'))\n          .map((v) => `\"${v}\"`)\n          .join(\",\"),\n      )\n      .join(\"\\r\\n\")\n  }\n\n  /**\n   * Converts an array of DownloadPacket objects to a JSON string.\n   * @returns {string} JSON string representation of the data.\n   * @private\n   *\n   * @example\n   * const jsonData = device.downloadToJSON();\n   * console.log(jsonData);\n   */\n  private downloadToJSON = (): string => {\n    // Pretty print JSON with 2-space indentation\n    return JSON.stringify(this.downloadPackets, null, 2)\n  }\n\n  /**\n   * Converts an array of DownloadPacket objects to an XML string.\n   * @returns {string}  XML string representation of the data.\n   * @private\n   *\n   * @example\n   * const xmlData = device.downloadToXML();\n   * console.log(xmlData);\n   */\n  private downloadToXML = (): string => {\n    const xmlPackets = this.downloadPackets\n      .map((packet) => {\n        const samples = packet.samples.map((sample) => `<sample>${sample}</sample>`).join(\"\")\n        const masses = packet.masses.map((mass) => `<mass>${mass}</mass>`).join(\"\")\n        return `\n          <packet>\n            <received>${packet.received}</received>\n            <sampleNum>${packet.sampleNum}</sampleNum>\n            <battRaw>${packet.battRaw}</battRaw>\n            <samples>${samples}</samples>\n            <masses>${masses}</masses>\n          </packet>\n        `\n      })\n      .join(\"\")\n    return `<DownloadPackets>${xmlPackets}</DownloadPackets>`\n  }\n\n  /**\n   * Exports the data in the specified format (CSV, JSON, XML) with a filename format:\n   * 'data-export-YYYY-MM-DD-HH-MM-SS.{format}'.\n   *\n   * @param {('csv' | 'json' | 'xml')} [format='csv'] - The format in which to download the data.\n   * Defaults to 'csv'. Accepted values are 'csv', 'json', and 'xml'.\n   *\n   * @returns {Promise<void>} Resolves when the data has been downloaded/written\n   * @public\n   *\n   * @example\n   * await device.download('json');\n   */\n  download = async (format: \"csv\" | \"json\" | \"xml\" = \"csv\"): Promise<void> => {\n    let content = \"\"\n\n    if (format === \"csv\") {\n      content = this.downloadToCSV()\n    } else if (format === \"json\") {\n      content = this.downloadToJSON()\n    } else if (format === \"xml\") {\n      content = this.downloadToXML()\n    }\n\n    const now = new Date()\n    // YYYY-MM-DD\n    const date = now.toISOString().split(\"T\")[0]\n    // HH-MM-SS\n    const time = now.toTimeString().split(\" \")[0].replace(/:/g, \"-\")\n\n    const fileName = `data-export-${date}-${time}.${format}`\n\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      const mimeTypes = {\n        csv: \"text/csv\",\n        json: \"application/json\",\n        xml: \"application/xml\",\n      }\n\n      // Create a Blob object containing the data\n      const blob = new Blob([content], { type: mimeTypes[format] })\n      // Create a URL for the Blob\n      const url = globalThis.URL.createObjectURL(blob)\n\n      // Create a link element\n      const link = document.createElement(\"a\")\n\n      // Set link attributes\n      link.href = url\n      link.setAttribute(\"download\", fileName)\n\n      // Append link to document body\n      document.body.appendChild(link)\n\n      // Programmatically click the link to trigger the download\n      link.click()\n\n      // Clean up: remove the link and revoke the URL\n      document.body.removeChild(link)\n      globalThis.URL.revokeObjectURL(url)\n    } else {\n      const { writeFile } = await import(\"node:fs/promises\")\n      await writeFile(fileName, content)\n      console.log(`File saved as ${fileName}`)\n    }\n  }\n\n  /**\n   * Returns UUIDs of all services associated with the device.\n   * @returns {string[]} Array of service UUIDs.\n   * @protected\n   *\n   * @example\n   * const serviceUUIDs = device.getAllServiceUUIDs();\n   * console.log(serviceUUIDs);\n   */\n  protected getAllServiceUUIDs = (): string[] => {\n    return this.services.filter((service) => service?.uuid).map((service) => service.uuid)\n  }\n\n  /**\n   * Attempt to use ES module import rather than require.\n   * This approach uses an async dynamic import for `webbluetooth`,\n   * so we can fallback if `navigator.bluetooth` is unavailable.\n   */\n  protected async getBluetooth() {\n    // If we're in a browser with real Web Bluetooth available:\n    if (typeof navigator !== \"undefined\" && \"bluetooth\" in navigator) {\n      return navigator.bluetooth\n    }\n\n    // Otherwise, we're likely in Node or an environment without `navigator.bluetooth`.\n    // Use a dynamic import for the ESM version:\n    const { bluetooth } = await import(\"webbluetooth\")\n    return bluetooth\n  }\n\n  /**\n   * Retrieves the characteristic from the device's service.\n   * @param {string} serviceId - The UUID of the service.\n   * @param {string} characteristicId - The UUID of the characteristic.\n   * @returns {BluetoothRemoteGATTCharacteristic | undefined} The characteristic, if found.\n   * @protected\n   *\n   * @example\n   * const characteristic = device.getCharacteristic('battery', 'level');\n   * if (characteristic) {\n   *   console.log('Characteristic found');\n   * }\n   */\n  protected getCharacteristic = (\n    serviceId: string,\n    characteristicId: string,\n  ): BluetoothRemoteGATTCharacteristic | undefined => {\n    // Find the service with the specified serviceId\n    const boardService = this.services.find((service) => service.id === serviceId)\n    if (boardService) {\n      // If the service is found, find the characteristic with the specified characteristicId\n      const boardCharacteristic = boardService.characteristics.find(\n        (characteristic) => characteristic.id === characteristicId,\n      )\n      if (boardCharacteristic) {\n        // If the characteristic is found, return it\n        return boardCharacteristic.characteristic\n      }\n    }\n    // Return undefined if the service or characteristic is not found\n    return undefined\n  }\n\n  /**\n   * Handles notifications received from a characteristic.\n   * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.\n   *\n   * @example\n   * device.handleNotifications(someCharacteristic);\n   */\n  protected handleNotifications = (characteristic: BluetoothRemoteGATTCharacteristic): void => {\n    const value = characteristic.value\n    if (!value) return\n\n    this.updateTimestamp()\n    // Received notification data\n    console.log(value)\n  }\n\n  /**\n   * Checks if a Bluetooth device is connected.\n   * @returns {boolean} A boolean indicating whether the device is connected.\n   * @public\n   *\n   * @example\n   * if (device.isConnected()) {\n   *   console.log('Device is connected');\n   * } else {\n   *   console.log('Device is not connected');\n   * }\n   */\n  isConnected = (): boolean => {\n    // Check if the device is defined and available\n    if (!this?.bluetooth) {\n      return false\n    }\n    // Check if the device is connected\n    return !!this.bluetooth.gatt?.connected\n  }\n\n  /**\n   * Sets the callback function to be called when notifications are received.\n   * @param {NotifyCallback} callback - The callback function to be set.\n   * @returns {void}\n   * @public\n   *\n   * @example\n   * device.notify((data) => {\n   *   console.log('Received notification:', data);\n   * });\n   */\n  notify = (callback: NotifyCallback): void => {\n    this.notifyCallback = callback\n  }\n\n  /**\n   * Handles the 'connected' event.\n   * @param {Function} onSuccess - Callback function to execute on successful connection.\n   * @public\n   *\n   * @example\n   * device.onConnected(() => {\n   *   console.log('Device connected successfully');\n   * });\n   */\n  protected onConnected = async (onSuccess: () => void): Promise<void> => {\n    this.updateTimestamp()\n\n    if (!this.server) {\n      throw new Error(\"GATT server is not available\")\n    }\n    // Connect to GATT server and set up characteristics\n    const services: BluetoothRemoteGATTService[] | undefined = await this.server.getPrimaryServices()\n\n    if (!services || services.length === 0) {\n      throw new Error(\"No services found\")\n    }\n\n    for (const service of services) {\n      const matchingService = this.services.find((boardService) => boardService.uuid === service.uuid)\n\n      if (matchingService) {\n        // Android bug: Introduce a delay before getting characteristics\n        await new Promise((resolve) => setTimeout(resolve, 100))\n\n        const characteristics = await service.getCharacteristics()\n\n        for (const characteristic of matchingService.characteristics) {\n          const matchingCharacteristic = characteristics.find((char) => char.uuid === characteristic.uuid)\n\n          if (matchingCharacteristic) {\n            const element = matchingService.characteristics.find((char) => char.uuid === matchingCharacteristic.uuid)\n            if (element) {\n              element.characteristic = matchingCharacteristic\n\n              // TODO: remove device-specific logic\n              if (element.id === \"rx\") {\n                matchingCharacteristic.startNotifications()\n                const listener = (event: Event) => {\n                  const target = event.target as BluetoothRemoteGATTCharacteristic\n                  if (target && target.value) {\n                    this.handleNotifications(target)\n                  }\n                }\n                matchingCharacteristic.addEventListener(\"characteristicvaluechanged\", listener)\n                this.notificationListeners.set(element.uuid, listener)\n              }\n            }\n          } else {\n            throw new Error(`Characteristic ${characteristic.uuid} not found in service ${service.uuid}`)\n          }\n        }\n      }\n    }\n\n    // Call the onSuccess callback after successful connection and setup\n    onSuccess()\n  }\n\n  /**\n   * Handles the 'disconnected' event.\n   * @param {Event} event - The 'disconnected' event.\n   * @public\n   *\n   * @example\n   * device.onDisconnected(event);\n   */\n  protected onDisconnected = (event: Event): void => {\n    console.warn(`Device ${(event.target as BluetoothDevice).name} is disconnected.`)\n    this.disconnect()\n  }\n\n  /**\n   * Reads the value of the specified characteristic from the device.\n   * @param {string} serviceId - The service ID where the characteristic belongs.\n   * @param {string} characteristicId - The characteristic ID to read from.\n   * @param {number} [duration=0] - The duration to wait before resolving the promise, in milliseconds.\n   * @returns {Promise<string | undefined>} A promise that resolves when the read operation is completed.\n   * @public\n   *\n   * @example\n   * const value = await device.read('battery', 'level', 1000);\n   * console.log('Battery level:', value);\n   */\n  read = async (serviceId: string, characteristicId: string, duration = 0): Promise<string | undefined> => {\n    if (!this.isConnected()) {\n      return undefined\n    }\n    // Get the characteristic from the service\n    const characteristic = this.getCharacteristic(serviceId, characteristicId)\n    if (!characteristic) {\n      throw new Error(`Characteristic \"${characteristicId}\" not found in service \"${serviceId}\"`)\n    }\n    this.updateTimestamp()\n    // Decode the value based on characteristicId and serviceId\n    let decodedValue: string\n    const decoder = new TextDecoder(\"utf-8\")\n    // Read the value from the characteristic\n    const value = await characteristic.readValue()\n\n    if (\n      (serviceId === \"battery\" || serviceId === \"humidity\" || serviceId === \"temperature\") &&\n      characteristicId === \"level\"\n    ) {\n      // This is battery-specific; return the first byte as the level\n      decodedValue = value.getUint8(0).toString()\n    } else {\n      // Otherwise use a UTF-8 decoder\n      decodedValue = decoder.decode(value)\n    }\n    // Wait for the specified duration before returning the result\n    if (duration > 0) {\n      await new Promise((resolve) => setTimeout(resolve, duration))\n    }\n\n    return decodedValue\n  }\n\n  /**\n   * Initiates the tare calibration process.\n   * @param {number} duration - The duration time for tare calibration.\n   * @returns {boolean} A boolean indicating whether the tare calibration was successful.\n   * @public\n   *\n   * @example\n   * const success = device.tare(5000);\n   * if (success) {\n   *   console.log('Tare calibration started');\n   * } else {\n   *   console.log('Tare calibration failed to start');\n   * }\n   */\n  tare(duration = 5000): boolean {\n    if (this.tareActive) return false\n    this.updateTimestamp()\n    this.tareActive = true\n    this.tareDuration = duration\n    this.tareSamples = []\n    this.tareStartTime = Date.now()\n    return true\n  }\n\n  /**\n   * Apply tare calibration to the provided sample.\n   * @param {number} sample - The sample to calibrate.\n   * @returns {number} The calibrated tare value.\n   * @protected\n   *\n   * @example\n   * const calibratedSample = device.applyTare(rawSample);\n   * console.log('Calibrated sample:', calibratedSample);\n   */\n  protected applyTare(sample: number): number {\n    if (this.tareActive && this.tareStartTime) {\n      // Add current sample to the tare samples array\n      this.tareSamples.push(sample)\n\n      // Check if the tare calibration duration has passed\n      if (Date.now() - this.tareStartTime >= this.tareDuration) {\n        // Calculate the average of the tare samples\n        const total = this.tareSamples.reduce((acc, sample) => acc + sample, 0)\n        this.tareCurrent = total / this.tareSamples.length\n\n        // Reset the tare calibration process\n        this.tareActive = false\n        this.tareStartTime = null\n        this.tareSamples = []\n      }\n    }\n    // Return the current tare-adjusted value\n    return this.tareCurrent\n  }\n\n  /**\n   * Updates the timestamp of the last device interaction.\n   * This method sets the updatedAt property to the current date and time.\n   * @protected\n   *\n   * @example\n   * device.updateTimestamp();\n   * console.log('Last updated:', device.updatedAt);\n   */\n  protected updateTimestamp = (): void => {\n    this.updatedAt = new Date()\n  }\n\n  /**\n   * Writes a message to the specified characteristic of a Bluetooth device and optionally provides a callback to handle responses.\n   * @param {string} serviceId - The service UUID of the Bluetooth device containing the target characteristic.\n   * @param {string} characteristicId - The characteristic UUID where the message will be written.\n   * @param {string | Uint8Array | undefined} message - The message to be written to the characteristic. It can be a string or a Uint8Array.\n   * @param {number} [duration=0] - Optional. The time in milliseconds to wait before resolving the promise. Defaults to 0 for immediate resolution.\n   * @param {WriteCallback} [callback=writeCallback] - Optional. A custom callback to handle the response after the write operation is successful.\n   * @returns {Promise<void>} A promise that resolves once the write operation is complete.\n   * @public\n   * @throws {Error} Throws an error if the characteristic is undefined.\n   *\n   * @example\n   * // Example usage of the write function with a custom callback\n   * await Progressor.write(\"progressor\", \"tx\", ProgressorCommands.GET_BATT_VLTG, 250, (data) => {\n   *   console.log(`Battery voltage: ${data}`);\n   * });\n   */\n  write = async (\n    serviceId: string,\n    characteristicId: string,\n    message: string | Uint8Array | undefined,\n    duration = 0,\n    callback: WriteCallback = this.writeCallback,\n  ): Promise<void> => {\n    // Check if not connected or no message is provided\n    if (!this.isConnected() || message === undefined) {\n      return Promise.resolve()\n    }\n    // Get the characteristic from the service\n    const characteristic = this.getCharacteristic(serviceId, characteristicId)\n    if (!characteristic) {\n      throw new Error(`Characteristic \"${characteristicId}\" not found in service \"${serviceId}\"`)\n    }\n    this.updateTimestamp()\n    // Convert the message to Uint8Array if it's a string\n    const valueToWrite: Uint8Array = typeof message === \"string\" ? new TextEncoder().encode(message) : message\n    // Write the value to the characteristic\n    await characteristic.writeValue(valueToWrite)\n    // Update the last written message\n    this.writeLast = message\n    // Assign the provided callback to `writeCallback`\n    this.writeCallback = callback\n    // If a duration is specified, resolve the promise after the duration\n    if (duration > 0) {\n      await new Promise<void>((resolve) => setTimeout(resolve, duration))\n    }\n  }\n}\n", "import { Device } from \"../device.model.js\"\nimport type { IKilterBoard } from \"../../interfaces/device/kilterboard.interface.js\"\n\n/**\n * For API level 2 and API level 3.\n * The first byte in the data is dependent on where the packet is in the message as a whole.\n * More details: https://github.com/1-max-1/fake_kilter_board\n */\nexport enum KilterBoardPacket {\n  /** If this packet is in the middle, the byte gets set to 77 (M). */\n  V2_MIDDLE = 77,\n  /** If this packet is the first packet in the message, then this byte gets set to 78 (N). */\n  V2_FIRST,\n  /** If this is the last packet in the message, this byte gets set to 79 (0). */\n  V2_LAST,\n  /** If this packet is the only packet in the message, the byte gets set to 80 (P). Note that this takes priority over the other conditions. */\n  V2_ONLY,\n  /** If this packet is in the middle, the byte gets set to 81 (Q). */\n  V3_MIDDLE,\n  /** If this packet is the first packet in the message, then this byte gets set to 82 (R). */\n  V3_FIRST,\n  /** If this is the last packet in the message, this byte gets set to 83 (S). */\n  V3_LAST,\n  /** If this packet is the only packet in the message, the byte gets set to 84 (T). Note that this takes priority over the other conditions. */\n  V3_ONLY,\n}\n/**\n * Extracted from placement_roles database table.\n */\nexport const KilterBoardPlacementRoles = [\n  {\n    id: 12,\n    product_id: 1,\n    position: 1,\n    name: \"start\",\n    full_name: \"Start\",\n    led_color: \"00FF00\",\n    screen_color: \"00DD00\",\n  },\n  {\n    id: 13,\n    product_id: 1,\n    position: 2,\n    name: \"middle\",\n    full_name: \"Middle\",\n    led_color: \"00FFFF\",\n    screen_color: \"00FFFF\",\n  },\n  {\n    id: 14,\n    product_id: 1,\n    position: 3,\n    name: \"finish\",\n    full_name: \"Finish\",\n    led_color: \"FF00FF\",\n    screen_color: \"FF00FF\",\n  },\n  {\n    id: 15,\n    product_id: 1,\n    position: 4,\n    name: \"foot\",\n    full_name: \"Foot Only\",\n    led_color: \"FFB600\",\n    screen_color: \"FFA500\",\n  },\n]\n\n/**\n * Represents a Aurora Climbing device.\n * Kilter Board, Tension Board, Decoy Board, Touchstone Board, Grasshopper Board, Aurora Board, So iLL Board\n * {@link https://auroraclimbing.com}\n */\nexport class KilterBoard extends Device implements IKilterBoard {\n  /**\n   * UUID for the Aurora Climbing Advertising service.\n   * This constant is used to identify the specific Bluetooth service for Kilter Boards.\n   * @type {string}\n   * @static\n   * @readonly\n   * @constant\n   */\n  static readonly AuroraUUID: string = \"4488b571-7806-4df6-bcff-a2897e4953ff\"\n\n  /**\n   * Maximum length of the message body for byte wrapping.\n   * This value defines the limit for the size of messages that can be sent or received\n   * to ensure proper byte wrapping in communication.\n   * @type {number}\n   * @private\n   * @readonly\n   * @constant\n   */\n  private static readonly messageBodyMaxLength: number = 255\n\n  /**\n   * Maximum length of the Bluetooth message chunk.\n   * This value sets the upper limit for the size of individual Bluetooth messages\n   * sent to and from the device to comply with Bluetooth protocol constraints.\n   * @type {number}\n   * @private\n   * @readonly\n   * @constant\n   */\n  private static readonly maxBluetoothMessageSize: number = 20\n\n  constructor() {\n    super({\n      filters: [\n        {\n          services: [KilterBoard.AuroraUUID],\n        },\n      ],\n      services: [\n        {\n          name: \"UART Nordic Service\",\n          id: \"uart\",\n          uuid: \"6e400001-b5a3-f393-e0a9-e50e24dcca9e\",\n          characteristics: [\n            {\n              name: \"TX\",\n              id: \"tx\",\n              uuid: \"6e400002-b5a3-f393-e0a9-e50e24dcca9e\",\n            },\n            // {\n            //   name: \"RX\",\n            //   id: \"rx\",\n            //   uuid: \"6e400003-b5a3-f393-e0a9-e50e24dcca9e\",\n            // },\n          ],\n        },\n      ],\n    })\n  }\n\n  /**\n   * Calculates the checksum for a byte array by summing up all bytes ot hre packet in a single-byte variable.\n   * @param data - The array of bytes to calculate the checksum for.\n   * @returns {number} The calculated checksum value.\n   */\n  private checksum(data: number[]): number {\n    let i = 0\n    for (const value of data) {\n      i = (i + value) & 255\n    }\n    return ~i & 255\n  }\n\n  /**\n   * Wraps a byte array with header and footer bytes for transmission.\n   * @param data - The array of bytes to wrap.\n   * @returns {number[]} The wrapped byte array.\n   */\n  private wrapBytes(data: number[]): number[] {\n    if (data.length > KilterBoard.messageBodyMaxLength) {\n      return []\n    }\n    /**\n  - 0x1\n  - len(packets)\n  - checksum(packets)\n  - 0x2\n  - *packets\n  - 0x3\n\n  First byte is always 1, the second is a number of packets, then checksum, then 2, packets themselves, and finally 3.\n   */\n    return [1, data.length, this.checksum(data), 2, ...data, 3]\n  }\n\n  /**\n   * Encodes a position into a byte array.\n   * The lowest 8 bits of the position get put in the first byte of the group.\n   * The highest 8 bits of the position get put in the second byte of the group.\n   * @param position - The position to encode.\n   * @returns {number[]} The encoded byte array representing the position.\n   */\n  private encodePosition(position: number): number[] {\n    const position1 = position & 255\n    const position2 = (position & 65280) >> 8\n\n    return [position1, position2]\n  }\n\n  /**\n   * Encodes a color string into a numeric representation.\n   * The rgb color, 3 bits for the R and G components, 2 bits for the B component, with the 3 R bits occupying the high end of the byte and the 2 B bits in the low end (hence 3 G bits in the middle).\n   * @param color - The color string in hexadecimal format (e.g., 'FFFFFF').\n   * @returns The encoded /compressed color value.\n   */\n  private encodeColor(color: string): number {\n    const substring = color.substring(0, 2)\n    const substring2 = color.substring(2, 4)\n\n    const parsedSubstring = parseInt(substring, 16) / 32\n    const parsedSubstring2 = parseInt(substring2, 16) / 32\n    const parsedResult = (parsedSubstring << 5) | (parsedSubstring2 << 2)\n\n    const substring3 = color.substring(4, 6)\n    const parsedSubstring3 = parseInt(substring3, 16) / 64\n    const finalParsedResult = parsedResult | parsedSubstring3\n\n    return finalParsedResult\n  }\n\n  /**\n   * Encodes a placement (requires a 16-bit position and a 24-bit rgb color. ) into a byte array.\n   * @param position - The position to encode.\n   * @param ledColor - The color of the LED in hexadecimal format (e.g., 'FFFFFF').\n   * @returns The encoded byte array representing the placement.\n   */\n  private encodePlacement(position: number, ledColor: string): number[] {\n    return [...this.encodePosition(position), this.encodeColor(ledColor)]\n  }\n\n  /**\n   * Prepares byte arrays for transmission based on a list of climb placements.\n   * @param {{ position: number; role_id: number }[]} climbPlacementList - The list of climb placements containing position and role ID.\n   * @returns {number[]} The final byte array ready for transmission.\n   */\n  private prepBytesV3(climbPlacementList: { position: number; role_id: number }[]): number[] {\n    const resultArray: number[][] = []\n    let tempArray: number[] = [KilterBoardPacket.V3_MIDDLE]\n\n    for (const climbPlacement of climbPlacementList) {\n      if (tempArray.length + 3 > KilterBoard.messageBodyMaxLength) {\n        resultArray.push(tempArray)\n        tempArray = [KilterBoardPacket.V3_MIDDLE]\n      }\n      const role = KilterBoardPlacementRoles.find((placement) => placement.id === climbPlacement.role_id)\n      if (!role) {\n        throw new Error(`Role with id ${climbPlacement.role_id} not found in placement_roles`)\n      }\n      const encodedPlacement = this.encodePlacement(climbPlacement.position, role.led_color)\n      tempArray.push(...encodedPlacement)\n    }\n\n    resultArray.push(tempArray)\n\n    if (resultArray.length === 1) {\n      resultArray[0][0] = KilterBoardPacket.V3_ONLY\n    } else if (resultArray.length > 1) {\n      resultArray[0][0] = KilterBoardPacket.V3_FIRST\n      resultArray[resultArray.length - 1][0] = KilterBoardPacket.V3_LAST\n    }\n\n    const finalResultArray: number[] = []\n    for (const currentArray of resultArray) {\n      finalResultArray.push(...this.wrapBytes(currentArray))\n    }\n\n    return finalResultArray\n  }\n\n  /**\n   * Splits a collection into slices of the specified length.\n   * https://github.com/ramda/ramda/blob/master/source/splitEvery.js\n   * @param {Number} n\n   * @param {Array} list\n   * @return {Array<number[]>}\n   */\n  private splitEvery(n: number, list: number[]): number[][] {\n    if (n <= 0) {\n      throw new Error(\"First argument to splitEvery must be a positive integer\")\n    }\n    const result = []\n    let idx = 0\n    while (idx < list.length) {\n      result.push(list.slice(idx, (idx += n)))\n    }\n    return result\n  }\n\n  /**\n   * The kilter board only supports messages of 20 bytes\n   * at a time. This method splits a full message into parts\n   * of 20 bytes\n   *\n   * @param buffer\n   */\n  private splitMessages = (buffer: number[]) =>\n    this.splitEvery(KilterBoard.maxBluetoothMessageSize, buffer).map((arr) => new Uint8Array(arr))\n\n  /**\n   * Sends a series of messages to a device.\n   */\n  private async writeMessageSeries(messages: Uint8Array[]) {\n    for (const message of messages) {\n      await this.write(\"uart\", \"tx\", message)\n    }\n  }\n\n  /**\n   * Configures the LEDs based on an array of climb placements.\n   * @param {{ position: number; role_id: number }[]} config - Array of climb placements for the LEDs.\n   * @returns {Promise<number[] | undefined>} A promise that resolves with the payload array for the Kilter Board if LED settings were applied, or `undefined` if no action was taken or for the Motherboard.\n   */\n  led = async (config: { position: number; role_id: number }[]): Promise<number[] | undefined> => {\n    // Handle Kilterboard logic: process placements and send payload if connected\n    if (Array.isArray(config)) {\n      // Prepares byte arrays for transmission based on a list of climb placements.\n      const payload = this.prepBytesV3(config)\n      if (this.isConnected()) {\n        await this.writeMessageSeries(this.splitMessages(payload))\n      }\n      return payload\n    }\n    return undefined\n  }\n}\n"],
  "mappings": ";;;;;AAEO,IAAe,YAAf,MAAyB;AAAA,EAO9B,YAAY,MAAa;AANzB;AAEA;AAEA;AAPF;AAUI,SAAK,KAAK,KAAK,QAAM,gBAAW,WAAX,mBAAmB;AAExC,SAAK,YAAY,KAAK;AACtB,SAAK,YAAY,KAAK;AAAA,EACxB;AACF;;;ACTO,IAAe,SAAf,cAA8B,UAA6B;AAAA,EA+KhE,YAAY,QAA0B;AACpC,UAAM,MAAM;AAxKd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAS;AAST;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAS;AAQT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAS;AAOT;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ;AAOR;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,aAAwC;AAKlD;AAAA;AAAA;AAAA;AAAA,wBAAU,YAAW;AAIrB;AAAA;AAAA;AAAA,wBAAQ,gBAAwD;AAAA,MAC9D,WAAW;AAAA,MACX,UAAU;AAAA,IACZ;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU;AAOV;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU;AAQV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU;AAQV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU;AAQV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,mBAAoC,CAAC;AAM/C;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,eAAc;AAMtB;AAAA;AAAA;AAAA;AAAA,wBAAQ,cAAa;AAMrB;AAAA;AAAA;AAAA;AAAA,wBAAQ,iBAA+B;AAMvC;AAAA;AAAA;AAAA;AAAA,wBAAQ,eAAwB,CAAC;AAMjC;AAAA;AAAA;AAAA;AAAA,wBAAQ,gBAAe;AASvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,kBAAiC,CAAC,SAAqB,QAAQ,IAAI,IAAI;AASjF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,iBAA+B,CAAC,SAAiB,QAAQ,IAAI,IAAI;AAS3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,kBAAiC,CAAC,SAAkB,QAAQ,IAAI,IAAI;AAS9E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,0BAAyB,CAAC,UAAiB,KAAK,eAAe,KAAK;AAS5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,yBAAwB,oBAAI,IAA2B;AAwC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCAAS,CAAC,UAA0B,YAA8D;AAChG,WAAK,iBAAiB;AAGtB,WAAK,eAAe;AAAA,QAClB,YAAW,mCAAS,cAAa,KAAK,aAAa;AAAA;AAAA,QACnD,WAAU,mCAAS,aAAY,KAAK,aAAa;AAAA;AAAA,MACnD;AAAA,IACF;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,iBAAgB,CAAC,UAAiC;AAC1D,aAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,cAAM,aAAa;AACnB,cAAM,EAAE,WAAW,SAAS,IAAI,KAAK;AACrC,mBAAW,MAAM;AAEf,gBAAM,YAAY,aAAa;AAC/B,cAAI,KAAK,aAAa,WAAW;AAC/B,iBAAK,WAAW;AAChB,gBAAI,KAAK,gBAAgB;AACvB,mBAAK,eAAe,SAAS;AAAA,YAC/B;AAAA,UACF;AACA,kBAAQ;AAAA,QACV,GAAG,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCAAU,OACR,YAAwB,MAAM,QAAQ,IAAI,wBAAwB,GAClE,UAAkC,CAAC,UAAU,QAAQ,MAAM,KAAK,MAC9C;AAClB,UAAI;AAEF,cAAM,iBAAiB,KAAK,mBAAmB;AAE/C,cAAM,YAAY,MAAM,KAAK,aAAa;AAE1C,aAAK,YAAY,MAAM,UAAU,cAAc;AAAA,UAC7C,SAAS,KAAK;AAAA,UACd,kBAAkB;AAAA,QACpB,CAAC;AAED,YAAI,CAAC,KAAK,UAAU,MAAM;AACxB,gBAAM,IAAI,MAAM,sCAAsC;AAAA,QACxD;AAEA,aAAK,UAAU,iBAAiB,0BAA0B,KAAK,sBAAsB;AAErF,aAAK,SAAS,MAAM,KAAK,UAAU,KAAK,QAAQ;AAEhD,YAAI,KAAK,OAAO,WAAW;AACzB,gBAAM,KAAK,YAAY,SAAS;AAAA,QAClC;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,KAAc;AAAA,MACxB;AAAA,IACF;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sCAAa,MAAY;AA3T3B;AA4TI,UAAI,KAAK,YAAY,GAAG;AACtB,aAAK,gBAAgB;AAErB,aAAK,SAAS,QAAQ,CAAC,YAAY;AACjC,kBAAQ,gBAAgB,QAAQ,CAAC,SAAS;AAExC,gBAAI,KAAK,kBAAkB,KAAK,OAAO,MAAM;AAC3C,mBAAK,eAAe,kBAAkB;AACtC,oBAAM,WAAW,KAAK,sBAAsB,IAAI,KAAK,IAAI;AACzD,kBAAI,UAAU;AACZ,qBAAK,eAAe,oBAAoB,8BAA8B,QAAQ;AAC9E,qBAAK,sBAAsB,OAAO,KAAK,IAAI;AAAA,cAC7C;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAED,mBAAK,cAAL,mBAAgB,oBAAoB,0BAA0B,KAAK;AAEnE,yBAAK,cAAL,mBAAgB,SAAhB,mBAAsB;AAEtB,aAAK,SAAS;AACd,aAAK,YAAY;AACjB,aAAK,WAAW;AAAA,MAClB;AAAA,IACF;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,iBAAgB,MAAc;AACpC,YAAM,UAAU,CAAC,GAAG,KAAK,eAAe;AACxC,UAAI,QAAQ,WAAW,GAAG;AACxB,eAAO;AAAA,MACT;AACA,aAAO,QACJ;AAAA,QAAI,CAAC,WACJ;AAAA,UACE,OAAO,SAAS,SAAS;AAAA,UACzB,OAAO,UAAU,SAAS;AAAA,UAC1B,OAAO,QAAQ,SAAS;AAAA,UACxB,GAAG,OAAO,QAAQ,IAAI,MAAM;AAAA,UAC5B,GAAG,OAAO,OAAO,IAAI,MAAM;AAAA,QAC7B,EACG,IAAI,CAAC,MAAM,EAAE,QAAQ,MAAM,IAAI,CAAC,EAChC,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,GAAG;AAAA,MACb,EACC,KAAK,MAAM;AAAA,IAChB;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,kBAAiB,MAAc;AAErC,aAAO,KAAK,UAAU,KAAK,iBAAiB,MAAM,CAAC;AAAA,IACrD;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,iBAAgB,MAAc;AACpC,YAAM,aAAa,KAAK,gBACrB,IAAI,CAAC,WAAW;AACf,cAAM,UAAU,OAAO,QAAQ,IAAI,CAAC,WAAW,WAAW,MAAM,WAAW,EAAE,KAAK,EAAE;AACpF,cAAM,SAAS,OAAO,OAAO,IAAI,CAAC,SAAS,SAAS,IAAI,SAAS,EAAE,KAAK,EAAE;AAC1E,eAAO;AAAA;AAAA,wBAES,OAAO,QAAQ;AAAA,yBACd,OAAO,SAAS;AAAA,uBAClB,OAAO,OAAO;AAAA,uBACd,OAAO;AAAA,sBACR,MAAM;AAAA;AAAA;AAAA,MAGtB,CAAC,EACA,KAAK,EAAE;AACV,aAAO,oBAAoB,UAAU;AAAA,IACvC;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oCAAW,OAAO,SAAiC,UAAyB;AAC1E,UAAI,UAAU;AAEd,UAAI,WAAW,OAAO;AACpB,kBAAU,KAAK,cAAc;AAAA,MAC/B,WAAW,WAAW,QAAQ;AAC5B,kBAAU,KAAK,eAAe;AAAA,MAChC,WAAW,WAAW,OAAO;AAC3B,kBAAU,KAAK,cAAc;AAAA,MAC/B;AAEA,YAAM,MAAM,oBAAI,KAAK;AAErB,YAAM,OAAO,IAAI,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AAE3C,YAAM,OAAO,IAAI,aAAa,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE,QAAQ,MAAM,GAAG;AAE/D,YAAM,WAAW,eAAe,IAAI,IAAI,IAAI,IAAI,MAAM;AAEtD,UAAI,OAAO,WAAW,eAAe,OAAO,aAAa,aAAa;AACpE,cAAM,YAAY;AAAA,UAChB,KAAK;AAAA,UACL,MAAM;AAAA,UACN,KAAK;AAAA,QACP;AAGA,cAAM,OAAO,IAAI,KAAK,CAAC,OAAO,GAAG,EAAE,MAAM,UAAU,MAAM,EAAE,CAAC;AAE5D,cAAM,MAAM,WAAW,IAAI,gBAAgB,IAAI;AAG/C,cAAM,OAAO,SAAS,cAAc,GAAG;AAGvC,aAAK,OAAO;AACZ,aAAK,aAAa,YAAY,QAAQ;AAGtC,iBAAS,KAAK,YAAY,IAAI;AAG9B,aAAK,MAAM;AAGX,iBAAS,KAAK,YAAY,IAAI;AAC9B,mBAAW,IAAI,gBAAgB,GAAG;AAAA,MACpC,OAAO;AACL,cAAM,EAAE,UAAU,IAAI,MAAM,OAAO,wBAAkB;AACrD,cAAM,UAAU,UAAU,OAAO;AACjC,gBAAQ,IAAI,iBAAiB,QAAQ,EAAE;AAAA,MACzC;AAAA,IACF;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,sBAAqB,MAAgB;AAC7C,aAAO,KAAK,SAAS,OAAO,CAAC,YAAY,mCAAS,IAAI,EAAE,IAAI,CAAC,YAAY,QAAQ,IAAI;AAAA,IACvF;AAgCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,qBAAoB,CAC5B,WACA,qBACkD;AAElD,YAAM,eAAe,KAAK,SAAS,KAAK,CAAC,YAAY,QAAQ,OAAO,SAAS;AAC7E,UAAI,cAAc;AAEhB,cAAM,sBAAsB,aAAa,gBAAgB;AAAA,UACvD,CAAC,mBAAmB,eAAe,OAAO;AAAA,QAC5C;AACA,YAAI,qBAAqB;AAEvB,iBAAO,oBAAoB;AAAA,QAC7B;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,uBAAsB,CAAC,mBAA4D;AAC3F,YAAM,QAAQ,eAAe;AAC7B,UAAI,CAAC,MAAO;AAEZ,WAAK,gBAAgB;AAErB,cAAQ,IAAI,KAAK;AAAA,IACnB;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uCAAc,MAAe;AA7jB/B;AA+jBI,UAAI,EAAC,6BAAM,YAAW;AACpB,eAAO;AAAA,MACT;AAEA,aAAO,CAAC,GAAC,UAAK,UAAU,SAAf,mBAAqB;AAAA,IAChC;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCAAS,CAAC,aAAmC;AAC3C,WAAK,iBAAiB;AAAA,IACxB;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,eAAc,OAAO,cAAyC;AACtE,WAAK,gBAAgB;AAErB,UAAI,CAAC,KAAK,QAAQ;AAChB,cAAM,IAAI,MAAM,8BAA8B;AAAA,MAChD;AAEA,YAAM,WAAqD,MAAM,KAAK,OAAO,mBAAmB;AAEhG,UAAI,CAAC,YAAY,SAAS,WAAW,GAAG;AACtC,cAAM,IAAI,MAAM,mBAAmB;AAAA,MACrC;AAEA,iBAAW,WAAW,UAAU;AAC9B,cAAM,kBAAkB,KAAK,SAAS,KAAK,CAAC,iBAAiB,aAAa,SAAS,QAAQ,IAAI;AAE/F,YAAI,iBAAiB;AAEnB,gBAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,GAAG,CAAC;AAEvD,gBAAM,kBAAkB,MAAM,QAAQ,mBAAmB;AAEzD,qBAAW,kBAAkB,gBAAgB,iBAAiB;AAC5D,kBAAM,yBAAyB,gBAAgB,KAAK,CAAC,SAAS,KAAK,SAAS,eAAe,IAAI;AAE/F,gBAAI,wBAAwB;AAC1B,oBAAM,UAAU,gBAAgB,gBAAgB,KAAK,CAAC,SAAS,KAAK,SAAS,uBAAuB,IAAI;AACxG,kBAAI,SAAS;AACX,wBAAQ,iBAAiB;AAGzB,oBAAI,QAAQ,OAAO,MAAM;AACvB,yCAAuB,mBAAmB;AAC1C,wBAAM,WAAW,CAAC,UAAiB;AACjC,0BAAM,SAAS,MAAM;AACrB,wBAAI,UAAU,OAAO,OAAO;AAC1B,2BAAK,oBAAoB,MAAM;AAAA,oBACjC;AAAA,kBACF;AACA,yCAAuB,iBAAiB,8BAA8B,QAAQ;AAC9E,uBAAK,sBAAsB,IAAI,QAAQ,MAAM,QAAQ;AAAA,gBACvD;AAAA,cACF;AAAA,YACF,OAAO;AACL,oBAAM,IAAI,MAAM,kBAAkB,eAAe,IAAI,yBAAyB,QAAQ,IAAI,EAAE;AAAA,YAC9F;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGA,gBAAU;AAAA,IACZ;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,kBAAiB,CAAC,UAAuB;AACjD,cAAQ,KAAK,UAAW,MAAM,OAA2B,IAAI,mBAAmB;AAChF,WAAK,WAAW;AAAA,IAClB;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gCAAO,OAAO,WAAmB,kBAA0B,WAAW,MAAmC;AACvG,UAAI,CAAC,KAAK,YAAY,GAAG;AACvB,eAAO;AAAA,MACT;AAEA,YAAM,iBAAiB,KAAK,kBAAkB,WAAW,gBAAgB;AACzE,UAAI,CAAC,gBAAgB;AACnB,cAAM,IAAI,MAAM,mBAAmB,gBAAgB,2BAA2B,SAAS,GAAG;AAAA,MAC5F;AACA,WAAK,gBAAgB;AAErB,UAAI;AACJ,YAAM,UAAU,IAAI,YAAY,OAAO;AAEvC,YAAM,QAAQ,MAAM,eAAe,UAAU;AAE7C,WACG,cAAc,aAAa,cAAc,cAAc,cAAc,kBACtE,qBAAqB,SACrB;AAEA,uBAAe,MAAM,SAAS,CAAC,EAAE,SAAS;AAAA,MAC5C,OAAO;AAEL,uBAAe,QAAQ,OAAO,KAAK;AAAA,MACrC;AAEA,UAAI,WAAW,GAAG;AAChB,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,QAAQ,CAAC;AAAA,MAC9D;AAEA,aAAO;AAAA,IACT;AAkEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAU,mBAAkB,MAAY;AACtC,WAAK,YAAY,oBAAI,KAAK;AAAA,IAC5B;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCAAQ,OACN,WACA,kBACA,SACA,WAAW,GACX,WAA0B,KAAK,kBACb;AAElB,UAAI,CAAC,KAAK,YAAY,KAAK,YAAY,QAAW;AAChD,eAAO,QAAQ,QAAQ;AAAA,MACzB;AAEA,YAAM,iBAAiB,KAAK,kBAAkB,WAAW,gBAAgB;AACzE,UAAI,CAAC,gBAAgB;AACnB,cAAM,IAAI,MAAM,mBAAmB,gBAAgB,2BAA2B,SAAS,GAAG;AAAA,MAC5F;AACA,WAAK,gBAAgB;AAErB,YAAM,eAA2B,OAAO,YAAY,WAAW,IAAI,YAAY,EAAE,OAAO,OAAO,IAAI;AAEnG,YAAM,eAAe,WAAW,YAAY;AAE5C,WAAK,YAAY;AAEjB,WAAK,gBAAgB;AAErB,UAAI,WAAW,GAAG;AAChB,cAAM,IAAI,QAAc,CAAC,YAAY,WAAW,SAAS,QAAQ,CAAC;AAAA,MACpE;AAAA,IACF;AA1oBE,SAAK,UAAU,OAAO,WAAW,CAAC;AAClC,SAAK,WAAW,OAAO,YAAY,CAAC;AACpC,SAAK,WAAW,OAAO,YAAY,CAAC;AACpC,SAAK,YAAY,OAAO;AAExB,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,SAAK,eAAe;AACpB,SAAK,iBAAiB;AAEtB,SAAK,YAAY,oBAAI,KAAK;AAC1B,SAAK,YAAY,oBAAI,KAAK;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgTA,MAAgB,eAAe;AAE7B,QAAI,OAAO,cAAc,eAAe,eAAe,WAAW;AAChE,aAAO,UAAU;AAAA,IACnB;AAIA,UAAM,EAAE,UAAU,IAAI,MAAM,OAAO,oBAAc;AACjD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgOA,KAAK,WAAW,KAAe;AAC7B,QAAI,KAAK,WAAY,QAAO;AAC5B,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAClB,SAAK,eAAe;AACpB,SAAK,cAAc,CAAC;AACpB,SAAK,gBAAgB,KAAK,IAAI;AAC9B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYU,UAAU,QAAwB;AAC1C,QAAI,KAAK,cAAc,KAAK,eAAe;AAEzC,WAAK,YAAY,KAAK,MAAM;AAG5B,UAAI,KAAK,IAAI,IAAI,KAAK,iBAAiB,KAAK,cAAc;AAExD,cAAM,QAAQ,KAAK,YAAY,OAAO,CAAC,KAAKA,YAAW,MAAMA,SAAQ,CAAC;AACtE,aAAK,cAAc,QAAQ,KAAK,YAAY;AAG5C,aAAK,aAAa;AAClB,aAAK,gBAAgB;AACrB,aAAK,cAAc,CAAC;AAAA,MACtB;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,EACd;AA8DF;;;AC3zBO,IAAK,oBAAL,kBAAKC,uBAAL;AAEL,EAAAA,sCAAA,eAAY,MAAZ;AAEA,EAAAA,sCAAA;AAEA,EAAAA,sCAAA;AAEA,EAAAA,sCAAA;AAEA,EAAAA,sCAAA;AAEA,EAAAA,sCAAA;AAEA,EAAAA,sCAAA;AAEA,EAAAA,sCAAA;AAhBU,SAAAA;AAAA,GAAA;AAqBL,IAAM,4BAA4B;AAAA,EACvC;AAAA,IACE,IAAI;AAAA,IACJ,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,MAAM;AAAA,IACN,WAAW;AAAA,IACX,WAAW;AAAA,IACX,cAAc;AAAA,EAChB;AAAA,EACA;AAAA,IACE,IAAI;AAAA,IACJ,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,MAAM;AAAA,IACN,WAAW;AAAA,IACX,WAAW;AAAA,IACX,cAAc;AAAA,EAChB;AAAA,EACA;AAAA,IACE,IAAI;AAAA,IACJ,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,MAAM;AAAA,IACN,WAAW;AAAA,IACX,WAAW;AAAA,IACX,cAAc;AAAA,EAChB;AAAA,EACA;AAAA,IACE,IAAI;AAAA,IACJ,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,MAAM;AAAA,IACN,WAAW;AAAA,IACX,WAAW;AAAA,IACX,cAAc;AAAA,EAChB;AACF;AAOO,IAAM,eAAN,MAAM,qBAAoB,OAA+B;AAAA,EAiC9D,cAAc;AACZ,UAAM;AAAA,MACJ,SAAS;AAAA,QACP;AAAA,UACE,UAAU,CAAC,aAAY,UAAU;AAAA,QACnC;AAAA,MACF;AAAA,MACA,UAAU;AAAA,QACR;AAAA,UACE,MAAM;AAAA,UACN,IAAI;AAAA,UACJ,MAAM;AAAA,UACN,iBAAiB;AAAA,YACf;AAAA,cACE,MAAM;AAAA,cACN,IAAI;AAAA,cACJ,MAAM;AAAA,YACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAMF;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAoJH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,iBAAgB,CAAC,WACvB,KAAK,WAAW,aAAY,yBAAyB,MAAM,EAAE,IAAI,CAAC,QAAQ,IAAI,WAAW,GAAG,CAAC;AAgB/F;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAM,OAAO,WAAmF;AAE9F,UAAI,MAAM,QAAQ,MAAM,GAAG;AAEzB,cAAM,UAAU,KAAK,YAAY,MAAM;AACvC,YAAI,KAAK,YAAY,GAAG;AACtB,gBAAM,KAAK,mBAAmB,KAAK,cAAc,OAAO,CAAC;AAAA,QAC3D;AACA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA,EA/KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,SAAS,MAAwB;AACvC,QAAI,IAAI;AACR,eAAW,SAAS,MAAM;AACxB,UAAK,IAAI,QAAS;AAAA,IACpB;AACA,WAAO,CAAC,IAAI;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,UAAU,MAA0B;AAC1C,QAAI,KAAK,SAAS,aAAY,sBAAsB;AAClD,aAAO,CAAC;AAAA,IACV;AAWA,WAAO,CAAC,GAAG,KAAK,QAAQ,KAAK,SAAS,IAAI,GAAG,GAAG,GAAG,MAAM,CAAC;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,eAAe,UAA4B;AACjD,UAAM,YAAY,WAAW;AAC7B,UAAM,aAAa,WAAW,UAAU;AAExC,WAAO,CAAC,WAAW,SAAS;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YAAY,OAAuB;AACzC,UAAM,YAAY,MAAM,UAAU,GAAG,CAAC;AACtC,UAAM,aAAa,MAAM,UAAU,GAAG,CAAC;AAEvC,UAAM,kBAAkB,SAAS,WAAW,EAAE,IAAI;AAClD,UAAM,mBAAmB,SAAS,YAAY,EAAE,IAAI;AACpD,UAAM,eAAgB,mBAAmB,IAAM,oBAAoB;AAEnE,UAAM,aAAa,MAAM,UAAU,GAAG,CAAC;AACvC,UAAM,mBAAmB,SAAS,YAAY,EAAE,IAAI;AACpD,UAAM,oBAAoB,eAAe;AAEzC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,gBAAgB,UAAkB,UAA4B;AACpE,WAAO,CAAC,GAAG,KAAK,eAAe,QAAQ,GAAG,KAAK,YAAY,QAAQ,CAAC;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,YAAY,oBAAuE;AACzF,UAAM,cAA0B,CAAC;AACjC,QAAI,YAAsB,CAAC,kBAA2B;AAEtD,eAAW,kBAAkB,oBAAoB;AAC/C,UAAI,UAAU,SAAS,IAAI,aAAY,sBAAsB;AAC3D,oBAAY,KAAK,SAAS;AAC1B,oBAAY,CAAC,kBAA2B;AAAA,MAC1C;AACA,YAAM,OAAO,0BAA0B,KAAK,CAAC,cAAc,UAAU,OAAO,eAAe,OAAO;AAClG,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,gBAAgB,eAAe,OAAO,+BAA+B;AAAA,MACvF;AACA,YAAM,mBAAmB,KAAK,gBAAgB,eAAe,UAAU,KAAK,SAAS;AACrF,gBAAU,KAAK,GAAG,gBAAgB;AAAA,IACpC;AAEA,gBAAY,KAAK,SAAS;AAE1B,QAAI,YAAY,WAAW,GAAG;AAC5B,kBAAY,CAAC,EAAE,CAAC,IAAI;AAAA,IACtB,WAAW,YAAY,SAAS,GAAG;AACjC,kBAAY,CAAC,EAAE,CAAC,IAAI;AACpB,kBAAY,YAAY,SAAS,CAAC,EAAE,CAAC,IAAI;AAAA,IAC3C;AAEA,UAAM,mBAA6B,CAAC;AACpC,eAAW,gBAAgB,aAAa;AACtC,uBAAiB,KAAK,GAAG,KAAK,UAAU,YAAY,CAAC;AAAA,IACvD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,WAAW,GAAW,MAA4B;AACxD,QAAI,KAAK,GAAG;AACV,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AACA,UAAM,SAAS,CAAC;AAChB,QAAI,MAAM;AACV,WAAO,MAAM,KAAK,QAAQ;AACxB,aAAO,KAAK,KAAK,MAAM,KAAM,OAAO,CAAE,CAAC;AAAA,IACzC;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAeA,MAAc,mBAAmB,UAAwB;AACvD,eAAW,WAAW,UAAU;AAC9B,YAAM,KAAK,MAAM,QAAQ,MAAM,OAAO;AAAA,IACxC;AAAA,EACF;AAmBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAnOE,cATW,cASK,cAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWrC,cApBW,cAoBa,wBAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWvD,cA/BW,cA+Ba,2BAAkC;AA/BrD,IAAM,cAAN;",
  "names": ["sample", "KilterBoardPacket"]
}
