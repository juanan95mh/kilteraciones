import {
  __publicField
} from "./chunk-KVCYZR2Q.js";

// node_modules/@hangtime/grip-connect/dist/models/base.model.js
var BaseModel = class {
  constructor(base) {
    __publicField(this, "id");
    __publicField(this, "createdAt");
    __publicField(this, "updatedAt");
    var _a;
    this.id = base.id ?? ((_a = globalThis.crypto) == null ? void 0 : _a.randomUUID());
    this.createdAt = base.createdAt;
    this.updatedAt = base.updatedAt;
  }
};

// node_modules/@hangtime/grip-connect/dist/models/device.model.js
var Device = class extends BaseModel {
  constructor(device) {
    super(device);
    /**
     * Filters to identify the device during Bluetooth scanning.
     * Used to match devices that meet specific criteria such as name, service UUIDs, etc.
     * @type {BluetoothLEScanFilter[]}
     * @public
     * @readonly
     */
    __publicField(this, "filters");
    /**
     * Array of services provided by the device.
     * Services represent functionalities that the device supports, such as weight measurement, battery information, or custom services.
     * @type {Service[]}
     * @public
     * @readonly
     */
    __publicField(this, "services");
    /**
     * Reference to the `BluetoothDevice` object representing this device.
     * This is the actual device object obtained from the Web Bluetooth API after a successful connection.
     * @type {BluetoothDevice | undefined}
     * @public
     */
    __publicField(this, "bluetooth");
    /**
     * Object representing the set of commands available for this device.
     * These commands allow communication with the device to perform various operations such as starting measurements, retrieving data, or calibrating the device.
     * @type {Commands}
     * @public
     * @readonly
     */
    __publicField(this, "commands");
    /**
     * The BluetoothRemoteGATTServer interface of the Web Bluetooth API represents a GATT Server on a remote device.
     * @type {BluetoothRemoteGATTServer | undefined}
     * @private
     */
    __publicField(this, "server");
    /**
     * The last message written to the device.
     * @type {string | Uint8Array | null}
     * @protected
     */
    __publicField(this, "writeLast", null);
    /**
     * Indicates whether the device is currently active.
     * @type {boolean}
     */
    __publicField(this, "isActive", false);
    /**
     * Configuration for threshold and duration.
     */
    __publicField(this, "activeConfig", {
      threshold: 2.5,
      duration: 1e3
    });
    /**
     * Maximum mass recorded from the device, initialized to "0".
     * @type {string}
     * @protected
     */
    __publicField(this, "massMax");
    /**
     * Average mass calculated from the device data, initialized to "0".
     * @type {string}
     * @protected
     */
    __publicField(this, "massAverage");
    /**
     * Total sum of all mass data points recorded from the device.
     * Used to calculate the average mass.
     * @type {number}
     * @protected
     */
    __publicField(this, "massTotalSum");
    /**
     * Number of data points received from the device.
     * Used to calculate the average mass.
     * @type {number}
     * @protected
     */
    __publicField(this, "dataPointCount");
    /**
     * Array of DownloadPacket entries.
     * This array holds packets that contain data downloaded from the device.
     * @type {DownloadPacket[]}
     * @protected
     */
    __publicField(this, "downloadPackets", []);
    // Initialize an empty array of DownloadPacket entries
    /**
     * Represents the current tare value for calibration.
     * @type {number}
     */
    __publicField(this, "tareCurrent", 0);
    /**
     * Indicates whether the tare calibration process is active.
     * @type {boolean}
     */
    __publicField(this, "tareActive", false);
    /**
     * Timestamp when the tare calibration process started.
     * @type {number | null}
     */
    __publicField(this, "tareStartTime", null);
    /**
     * Array holding the samples collected during tare calibration.
     * @type {number[]}
     */
    __publicField(this, "tareSamples", []);
    /**
     * Duration time for the tare calibration process.
     * @type {number}
     */
    __publicField(this, "tareDuration", 5e3);
    /**
     * Optional callback for handling write operations.
     * @callback NotifyCallback
     * @param {massObject} data - The data passed to the callback.
     * @type {NotifyCallback | undefined}
     * @protected
     */
    __publicField(this, "notifyCallback", (data) => console.log(data));
    /**
     * Optional callback for handling write operations.
     * @callback WriteCallback
     * @param {string} data - The data passed to the callback.
     * @type {WriteCallback | undefined}
     * @protected
     */
    __publicField(this, "writeCallback", (data) => console.log(data));
    /**
     * Optional callback for handling write operations.
     * @callback ActiveCallback
     * @param {string} data - The data passed to the callback.
     * @type {ActiveCallback | undefined}
     * @protected
     */
    __publicField(this, "activeCallback", (data) => console.log(data));
    /**
     * Event listener for handling the 'gattserverdisconnected' event.
     * This listener delegates the event to the `onDisconnected` method.
     *
     * @private
     * @type {(event: Event) => void}
     */
    __publicField(this, "onDisconnectedListener", (event) => this.onDisconnected(event));
    /**
     * A map that stores notification event listeners keyed by characteristic UUIDs.
     * This allows for proper addition and removal of event listeners associated with each characteristic.
     *
     * @private
     * @type {Map<string, EventListener>}
     */
    __publicField(this, "notificationListeners", /* @__PURE__ */ new Map());
    /**
     * Sets the callback function to be called when the activity status changes,
     * and optionally sets the configuration for threshold and duration.
     *
     * This function allows you to specify a callback that will be invoked whenever
     * the activity status changes, indicating whether the device is currently active.
     * It also allows optionally configuring the threshold and duration used to determine activity.
     *
     * @param {ActiveCallback} callback - The callback function to be set. This function
     *                                      receives a boolean value indicating the new activity status.
     * @param {object} [options] - Optional configuration object containing the threshold and duration.
     * @param {number} [options.threshold=2.5] - The threshold value for determining activity.
     * @param {number} [options.duration=1000] - The duration (in milliseconds) to monitor the input for activity.
     * @returns {void}
     * @public
     *
     * @example
     * device.active((isActive) => {
     *   console.log(`Device is ${isActive ? 'active' : 'inactive'}`);
     * }, { threshold: 3.0, duration: 1500 });
     */
    __publicField(this, "active", (callback, options) => {
      this.activeCallback = callback;
      this.activeConfig = {
        threshold: (options == null ? void 0 : options.threshold) ?? this.activeConfig.threshold,
        // Use new threshold if provided, else use default
        duration: (options == null ? void 0 : options.duration) ?? this.activeConfig.duration
        // Use new duration if provided, else use default
      };
    });
    /**
     * Checks if a dynamic value is active based on a threshold and duration.
     *
     * This function assesses whether a given dynamic value surpasses a specified threshold
     * and remains active for a specified duration. If the activity status changes from
     * the previous state, the callback function is called with the updated activity status.
     *
     * @param {number} input - The dynamic value to check for activity status.
     * @returns {Promise<void>} A promise that resolves once the activity check is complete.
     *
     * @example
     * await device.activityCheck(5.0);
     */
    __publicField(this, "activityCheck", (input) => {
      return new Promise((resolve) => {
        const startValue = input;
        const { threshold, duration } = this.activeConfig;
        setTimeout(() => {
          const activeNow = startValue > threshold;
          if (this.isActive !== activeNow) {
            this.isActive = activeNow;
            if (this.activeCallback) {
              this.activeCallback(activeNow);
            }
          }
          resolve();
        }, duration);
      });
    });
    /**
     * Connects to a Bluetooth device.
     * @param {Function} [onSuccess] - Optional callback function to execute on successful connection. Default logs success.
     * @param {Function} [onError] - Optional callback function to execute on error. Default logs the error.
     * @public
     *
     * @example
     * device.connect(
     *   () => console.log("Connected successfully"),
     *   (error) => console.error("Connection failed:", error)
     * );
     */
    __publicField(this, "connect", async (onSuccess = () => console.log("Connected successfully"), onError = (error) => console.error(error)) => {
      try {
        const deviceServices = this.getAllServiceUUIDs();
        const bluetooth = await this.getBluetooth();
        this.bluetooth = await bluetooth.requestDevice({
          filters: this.filters,
          optionalServices: deviceServices
        });
        if (!this.bluetooth.gatt) {
          throw new Error("GATT is not available on this device");
        }
        this.bluetooth.addEventListener("gattserverdisconnected", this.onDisconnectedListener);
        this.server = await this.bluetooth.gatt.connect();
        if (this.server.connected) {
          await this.onConnected(onSuccess);
        }
      } catch (error) {
        onError(error);
      }
    });
    /**
     * Disconnects the device if it is currently connected.
     * - Removes all notification listeners from the device's characteristics.
     * - Removes the 'gattserverdisconnected' event listener.
     * - Attempts to gracefully disconnect the device's GATT server.
     * - Resets relevant properties to their initial states.
     * @returns {void}
     * @public
     *
     * @example
     * device.disconnect();
     */
    __publicField(this, "disconnect", () => {
      var _a, _b, _c;
      if (this.isConnected()) {
        this.updateTimestamp();
        this.services.forEach((service) => {
          service.characteristics.forEach((char) => {
            if (char.characteristic && char.id === "rx") {
              char.characteristic.stopNotifications();
              const listener = this.notificationListeners.get(char.uuid);
              if (listener) {
                char.characteristic.removeEventListener("characteristicvaluechanged", listener);
                this.notificationListeners.delete(char.uuid);
              }
            }
          });
        });
        (_a = this.bluetooth) == null ? void 0 : _a.removeEventListener("gattserverdisconnected", this.onDisconnectedListener);
        (_c = (_b = this.bluetooth) == null ? void 0 : _b.gatt) == null ? void 0 : _c.disconnect();
        this.server = void 0;
        this.writeLast = null;
        this.isActive = false;
      }
    });
    /**
     * Converts the `downloadPackets` array into a CSV formatted string.
     * @returns {string} A CSV string representation of the `downloadPackets` data, with each packet on a new line.
     * @private
     *
     * @example
     * const csvData = device.downloadToCSV();
     * console.log(csvData);
     */
    __publicField(this, "downloadToCSV", () => {
      const packets = [...this.downloadPackets];
      if (packets.length === 0) {
        return "";
      }
      return packets.map((packet) => [
        packet.received.toString(),
        packet.sampleNum.toString(),
        packet.battRaw.toString(),
        ...packet.samples.map(String),
        ...packet.masses.map(String)
      ].map((v) => v.replace(/"/g, '""')).map((v) => `"${v}"`).join(",")).join("\r\n");
    });
    /**
     * Converts an array of DownloadPacket objects to a JSON string.
     * @returns {string} JSON string representation of the data.
     * @private
     *
     * @example
     * const jsonData = device.downloadToJSON();
     * console.log(jsonData);
     */
    __publicField(this, "downloadToJSON", () => {
      return JSON.stringify(this.downloadPackets, null, 2);
    });
    /**
     * Converts an array of DownloadPacket objects to an XML string.
     * @returns {string}  XML string representation of the data.
     * @private
     *
     * @example
     * const xmlData = device.downloadToXML();
     * console.log(xmlData);
     */
    __publicField(this, "downloadToXML", () => {
      const xmlPackets = this.downloadPackets.map((packet) => {
        const samples = packet.samples.map((sample) => `<sample>${sample}</sample>`).join("");
        const masses = packet.masses.map((mass) => `<mass>${mass}</mass>`).join("");
        return `
          <packet>
            <received>${packet.received}</received>
            <sampleNum>${packet.sampleNum}</sampleNum>
            <battRaw>${packet.battRaw}</battRaw>
            <samples>${samples}</samples>
            <masses>${masses}</masses>
          </packet>
        `;
      }).join("");
      return `<DownloadPackets>${xmlPackets}</DownloadPackets>`;
    });
    /**
     * Exports the data in the specified format (CSV, JSON, XML) with a filename format:
     * 'data-export-YYYY-MM-DD-HH-MM-SS.{format}'.
     *
     * @param {('csv' | 'json' | 'xml')} [format='csv'] - The format in which to download the data.
     * Defaults to 'csv'. Accepted values are 'csv', 'json', and 'xml'.
     *
     * @returns {Promise<void>} Resolves when the data has been downloaded/written
     * @public
     *
     * @example
     * await device.download('json');
     */
    __publicField(this, "download", async (format = "csv") => {
      let content = "";
      if (format === "csv") {
        content = this.downloadToCSV();
      } else if (format === "json") {
        content = this.downloadToJSON();
      } else if (format === "xml") {
        content = this.downloadToXML();
      }
      const now = /* @__PURE__ */ new Date();
      const date = now.toISOString().split("T")[0];
      const time = now.toTimeString().split(" ")[0].replace(/:/g, "-");
      const fileName = `data-export-${date}-${time}.${format}`;
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        const mimeTypes = {
          csv: "text/csv",
          json: "application/json",
          xml: "application/xml"
        };
        const blob = new Blob([content], { type: mimeTypes[format] });
        const url = globalThis.URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", fileName);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        globalThis.URL.revokeObjectURL(url);
      } else {
        const { writeFile } = await import("./promises-BEBUHVUU.js");
        await writeFile(fileName, content);
        console.log(`File saved as ${fileName}`);
      }
    });
    /**
     * Returns UUIDs of all services associated with the device.
     * @returns {string[]} Array of service UUIDs.
     * @protected
     *
     * @example
     * const serviceUUIDs = device.getAllServiceUUIDs();
     * console.log(serviceUUIDs);
     */
    __publicField(this, "getAllServiceUUIDs", () => {
      return this.services.filter((service) => service == null ? void 0 : service.uuid).map((service) => service.uuid);
    });
    /**
     * Retrieves the characteristic from the device's service.
     * @param {string} serviceId - The UUID of the service.
     * @param {string} characteristicId - The UUID of the characteristic.
     * @returns {BluetoothRemoteGATTCharacteristic | undefined} The characteristic, if found.
     * @protected
     *
     * @example
     * const characteristic = device.getCharacteristic('battery', 'level');
     * if (characteristic) {
     *   console.log('Characteristic found');
     * }
     */
    __publicField(this, "getCharacteristic", (serviceId, characteristicId) => {
      const boardService = this.services.find((service) => service.id === serviceId);
      if (boardService) {
        const boardCharacteristic = boardService.characteristics.find((characteristic) => characteristic.id === characteristicId);
        if (boardCharacteristic) {
          return boardCharacteristic.characteristic;
        }
      }
      return void 0;
    });
    /**
     * Handles notifications received from a characteristic.
     * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.
     *
     * @example
     * device.handleNotifications(someCharacteristic);
     */
    __publicField(this, "handleNotifications", (characteristic) => {
      const value = characteristic.value;
      if (!value)
        return;
      this.updateTimestamp();
      console.log(value);
    });
    /**
     * Checks if a Bluetooth device is connected.
     * @returns {boolean} A boolean indicating whether the device is connected.
     * @public
     *
     * @example
     * if (device.isConnected()) {
     *   console.log('Device is connected');
     * } else {
     *   console.log('Device is not connected');
     * }
     */
    __publicField(this, "isConnected", () => {
      var _a;
      if (!(this == null ? void 0 : this.bluetooth)) {
        return false;
      }
      return !!((_a = this.bluetooth.gatt) == null ? void 0 : _a.connected);
    });
    /**
     * Sets the callback function to be called when notifications are received.
     * @param {NotifyCallback} callback - The callback function to be set.
     * @returns {void}
     * @public
     *
     * @example
     * device.notify((data) => {
     *   console.log('Received notification:', data);
     * });
     */
    __publicField(this, "notify", (callback) => {
      this.notifyCallback = callback;
    });
    /**
     * Handles the 'connected' event.
     * @param {Function} onSuccess - Callback function to execute on successful connection.
     * @public
     *
     * @example
     * device.onConnected(() => {
     *   console.log('Device connected successfully');
     * });
     */
    __publicField(this, "onConnected", async (onSuccess) => {
      this.updateTimestamp();
      if (!this.server) {
        throw new Error("GATT server is not available");
      }
      const services = await this.server.getPrimaryServices();
      if (!services || services.length === 0) {
        throw new Error("No services found");
      }
      for (const service of services) {
        const matchingService = this.services.find((boardService) => boardService.uuid === service.uuid);
        if (matchingService) {
          await new Promise((resolve) => setTimeout(resolve, 100));
          const characteristics = await service.getCharacteristics();
          for (const characteristic of matchingService.characteristics) {
            const matchingCharacteristic = characteristics.find((char) => char.uuid === characteristic.uuid);
            if (matchingCharacteristic) {
              const element = matchingService.characteristics.find((char) => char.uuid === matchingCharacteristic.uuid);
              if (element) {
                element.characteristic = matchingCharacteristic;
                if (element.id === "rx") {
                  matchingCharacteristic.startNotifications();
                  const listener = (event) => {
                    const target = event.target;
                    if (target && target.value) {
                      this.handleNotifications(target);
                    }
                  };
                  matchingCharacteristic.addEventListener("characteristicvaluechanged", listener);
                  this.notificationListeners.set(element.uuid, listener);
                }
              }
            } else {
              throw new Error(`Characteristic ${characteristic.uuid} not found in service ${service.uuid}`);
            }
          }
        }
      }
      onSuccess();
    });
    /**
     * Handles the 'disconnected' event.
     * @param {Event} event - The 'disconnected' event.
     * @public
     *
     * @example
     * device.onDisconnected(event);
     */
    __publicField(this, "onDisconnected", (event) => {
      console.warn(`Device ${event.target.name} is disconnected.`);
      this.disconnect();
    });
    /**
     * Reads the value of the specified characteristic from the device.
     * @param {string} serviceId - The service ID where the characteristic belongs.
     * @param {string} characteristicId - The characteristic ID to read from.
     * @param {number} [duration=0] - The duration to wait before resolving the promise, in milliseconds.
     * @returns {Promise<string | undefined>} A promise that resolves when the read operation is completed.
     * @public
     *
     * @example
     * const value = await device.read('battery', 'level', 1000);
     * console.log('Battery level:', value);
     */
    __publicField(this, "read", async (serviceId, characteristicId, duration = 0) => {
      if (!this.isConnected()) {
        return void 0;
      }
      const characteristic = this.getCharacteristic(serviceId, characteristicId);
      if (!characteristic) {
        throw new Error(`Characteristic "${characteristicId}" not found in service "${serviceId}"`);
      }
      this.updateTimestamp();
      let decodedValue;
      const decoder = new TextDecoder("utf-8");
      const value = await characteristic.readValue();
      if ((serviceId === "battery" || serviceId === "humidity" || serviceId === "temperature") && characteristicId === "level") {
        decodedValue = value.getUint8(0).toString();
      } else {
        decodedValue = decoder.decode(value);
      }
      if (duration > 0) {
        await new Promise((resolve) => setTimeout(resolve, duration));
      }
      return decodedValue;
    });
    /**
     * Updates the timestamp of the last device interaction.
     * This method sets the updatedAt property to the current date and time.
     * @protected
     *
     * @example
     * device.updateTimestamp();
     * console.log('Last updated:', device.updatedAt);
     */
    __publicField(this, "updateTimestamp", () => {
      this.updatedAt = /* @__PURE__ */ new Date();
    });
    /**
     * Writes a message to the specified characteristic of a Bluetooth device and optionally provides a callback to handle responses.
     * @param {string} serviceId - The service UUID of the Bluetooth device containing the target characteristic.
     * @param {string} characteristicId - The characteristic UUID where the message will be written.
     * @param {string | Uint8Array | undefined} message - The message to be written to the characteristic. It can be a string or a Uint8Array.
     * @param {number} [duration=0] - Optional. The time in milliseconds to wait before resolving the promise. Defaults to 0 for immediate resolution.
     * @param {WriteCallback} [callback=writeCallback] - Optional. A custom callback to handle the response after the write operation is successful.
     * @returns {Promise<void>} A promise that resolves once the write operation is complete.
     * @public
     * @throws {Error} Throws an error if the characteristic is undefined.
     *
     * @example
     * // Example usage of the write function with a custom callback
     * await Progressor.write("progressor", "tx", ProgressorCommands.GET_BATT_VLTG, 250, (data) => {
     *   console.log(`Battery voltage: ${data}`);
     * });
     */
    __publicField(this, "write", async (serviceId, characteristicId, message, duration = 0, callback = this.writeCallback) => {
      if (!this.isConnected() || message === void 0) {
        return Promise.resolve();
      }
      const characteristic = this.getCharacteristic(serviceId, characteristicId);
      if (!characteristic) {
        throw new Error(`Characteristic "${characteristicId}" not found in service "${serviceId}"`);
      }
      this.updateTimestamp();
      const valueToWrite = typeof message === "string" ? new TextEncoder().encode(message) : message;
      await characteristic.writeValue(valueToWrite);
      this.writeLast = message;
      this.writeCallback = callback;
      if (duration > 0) {
        await new Promise((resolve) => setTimeout(resolve, duration));
      }
    });
    this.filters = device.filters || [];
    this.services = device.services || [];
    this.commands = device.commands || {};
    this.bluetooth = device.bluetooth;
    this.massMax = "0";
    this.massAverage = "0";
    this.massTotalSum = 0;
    this.dataPointCount = 0;
    this.createdAt = /* @__PURE__ */ new Date();
    this.updatedAt = /* @__PURE__ */ new Date();
  }
  /**
   * Attempt to use ES module import rather than require.
   * This approach uses an async dynamic import for `webbluetooth`,
   * so we can fallback if `navigator.bluetooth` is unavailable.
   */
  async getBluetooth() {
    if (typeof navigator !== "undefined" && "bluetooth" in navigator) {
      return navigator.bluetooth;
    }
    const { bluetooth } = await import("./dist-X7KCSCB7.js");
    return bluetooth;
  }
  /**
   * Initiates the tare calibration process.
   * @param {number} duration - The duration time for tare calibration.
   * @returns {boolean} A boolean indicating whether the tare calibration was successful.
   * @public
   *
   * @example
   * const success = device.tare(5000);
   * if (success) {
   *   console.log('Tare calibration started');
   * } else {
   *   console.log('Tare calibration failed to start');
   * }
   */
  tare(duration = 5e3) {
    if (this.tareActive)
      return false;
    this.updateTimestamp();
    this.tareActive = true;
    this.tareDuration = duration;
    this.tareSamples = [];
    this.tareStartTime = Date.now();
    return true;
  }
  /**
   * Apply tare calibration to the provided sample.
   * @param {number} sample - The sample to calibrate.
   * @returns {number} The calibrated tare value.
   * @protected
   *
   * @example
   * const calibratedSample = device.applyTare(rawSample);
   * console.log('Calibrated sample:', calibratedSample);
   */
  applyTare(sample) {
    if (this.tareActive && this.tareStartTime) {
      this.tareSamples.push(sample);
      if (Date.now() - this.tareStartTime >= this.tareDuration) {
        const total = this.tareSamples.reduce((acc, sample2) => acc + sample2, 0);
        this.tareCurrent = total / this.tareSamples.length;
        this.tareActive = false;
        this.tareStartTime = null;
        this.tareSamples = [];
      }
    }
    return this.tareCurrent;
  }
};

// node_modules/@hangtime/grip-connect/dist/models/device/climbro.model.js
var Climbro = class extends Device {
  constructor() {
    super({
      filters: [{ name: "Climbro" }],
      services: []
    });
  }
};

// node_modules/@hangtime/grip-connect/dist/models/device/entralpi.model.js
var Entralpi = class extends Device {
  constructor() {
    super({
      filters: [
        {
          name: "ENTRALPI"
        }
      ],
      services: [
        {
          name: "Device Information",
          id: "device",
          uuid: "0000180a-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "System ID",
              id: "system",
              uuid: "00002a23-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "Model Number String",
              id: "model",
              uuid: "00002a24-0000-1000-8000-00805f9b34fb"
            },
            // {
            //   name: "Serial Number String (Blocked)",
            //   id: "serial",
            //   uuid: "00002a25-0000-1000-8000-00805f9b34fb",
            // },
            {
              name: "Firmware Revision String",
              id: "firmware",
              uuid: "00002a26-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "Hardware Revision String",
              id: "hardware",
              uuid: "00002a27-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "Software Revision String",
              id: "software",
              uuid: "00002a28-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "Manufacturer Name String",
              id: "manufacturer",
              uuid: "00002a29-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "IEEE 11073-20601 Regulatory Certification Data List",
              id: "certification",
              uuid: "00002a2a-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "PnP ID",
              id: "pnp",
              uuid: "00002a50-0000-1000-8000-00805f9b34fb"
            }
          ]
        },
        {
          name: "Battery Service",
          id: "battery",
          uuid: "0000180f-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "Battery Level",
              id: "level",
              uuid: "00002a19-0000-1000-8000-00805f9b34fb"
            }
          ]
        },
        {
          name: "Generic Attribute",
          id: "attribute",
          uuid: "f000ffc0-0451-4000-b000-000000000000",
          characteristics: [
            {
              name: "",
              id: "",
              uuid: "f000ffc1-0451-4000-b000-000000000000"
            },
            {
              name: "",
              id: "",
              uuid: "f000ffc2-0451-4000-b000-000000000000"
            }
          ]
        },
        {
          name: "UART ISSC Transparent Service",
          id: "uart",
          uuid: "0000fff0-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "TX",
              id: "tx",
              uuid: "0000fff1-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "RX",
              id: "rx",
              uuid: "0000fff4-0000-1000-8000-00805f9b34fb"
            }
          ]
        },
        {
          name: "Weight Scale",
          id: "weight",
          uuid: "0000181d-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "notify",
              id: "rx",
              uuid: "0000fff1-0000-1000-8000-00805f9b34fb"
            }
          ]
        }
      ]
    });
    /**
     * Retrieves battery or voltage information from the device.
     * @returns {Promise<string | undefined>} A Promise that resolves with the battery or voltage information.
     */
    __publicField(this, "battery", async () => {
      return await this.read("battery", "level", 250);
    });
    /**
     * Retrieves IEEE 11073-20601 Regulatory Certification from the device.
     * @returns {Promise<string>} A Promise that resolves with the certification.
     */
    __publicField(this, "certification", async () => {
      return await this.read("device", "certification", 250);
    });
    /**
     * Retrieves firmware version from the device.
     * @returns {Promise<string>} A Promise that resolves with the firmware version.
     */
    __publicField(this, "firmware", async () => {
      return await this.read("device", "firmware", 250);
    });
    /**
     * Handles data received from the device, processes weight measurements,
     * and updates mass data including maximum and average values.
     * It also handles command responses for retrieving device information.
     *
     * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.
     */
    __publicField(this, "handleNotifications", (characteristic) => {
      const value = characteristic.value;
      if (value) {
        this.updateTimestamp();
        if (value.buffer) {
          const receivedTime = Date.now();
          const receivedData = (value.getUint16(0) / 100).toFixed(1);
          const convertedData = Number(receivedData);
          const tare = this.applyTare(convertedData);
          const numericData = tare === 0 ? convertedData : (convertedData - tare) * -1;
          this.downloadPackets.push({
            received: receivedTime,
            sampleNum: this.dataPointCount,
            battRaw: 0,
            samples: [convertedData],
            masses: [numericData]
          });
          this.massMax = Math.max(Number(this.massMax), numericData).toFixed(1);
          const currentMassTotal = Math.max(-1e3, numericData);
          this.massTotalSum += currentMassTotal;
          this.dataPointCount++;
          this.massAverage = (this.massTotalSum / this.dataPointCount).toFixed(1);
          this.activityCheck(numericData);
          this.notifyCallback({
            massMax: this.massMax,
            massAverage: this.massAverage,
            massTotal: Math.max(-1e3, numericData).toFixed(1)
          });
        }
      }
    });
    /**
     * Retrieves hardware version from the device.
     * @returns {Promise<string>} A Promise that resolves with the hardware version.
     */
    __publicField(this, "hardware", async () => {
      return await this.read("device", "hardware", 250);
    });
    /**
     * Retrieves manufacturer information from the device.
     * @returns {Promise<string>} A Promise that resolves with the manufacturer information.
     */
    __publicField(this, "manufacturer", async () => {
      return await this.read("device", "manufacturer", 250);
    });
    /**
     * Retrieves model number from the device.
     * @returns {Promise<string>} A Promise that resolves with the model number.
     */
    __publicField(this, "model", async () => {
      return await this.read("device", "model", 250);
    });
    /**
     * Retrieves PnP ID from the device, a set of values that used to create a device ID value that is unique for this device.
     * Included in the characteristic is a Vendor ID Source field, a Vendor ID field, a Product ID field and a Product Version field
     * @returns {Promise<string>} A Promise that resolves with the PnP ID.
     */
    __publicField(this, "pnp", async () => {
      return await this.read("device", "pnp", 250);
    });
    /**
     * Retrieves software version from the device.
     * @returns {Promise<string>} A Promise that resolves with the software version.
     */
    __publicField(this, "software", async () => {
      return await this.read("device", "software", 250);
    });
    /**
     * Retrieves system id from the device.
     * @returns {Promise<string>} A Promise that resolves with the system id.
     */
    __publicField(this, "system", async () => {
      return await this.read("device", "system", 250);
    });
  }
};

// node_modules/@hangtime/grip-connect/dist/models/device/forceboard.model.js
var ForceBoard = class extends Device {
  constructor() {
    super({
      filters: [{ name: "Force Board" }],
      services: [
        {
          name: "Device Information",
          id: "device",
          uuid: "0000180a-0000-1000-8000-00805f9b34fb",
          characteristics: [
            // {
            //   name: "Serial Number String (Blocked)",
            //   id: "serial",
            //   uuid: "00002a25-0000-1000-8000-00805f9b34fb",
            // },
            // {
            //   name: "Firmware Revision String (Blocked)",
            //   id: "firmware",
            //   uuid: "00002a26-0000-1000-8000-00805f9b34f",
            // },
            {
              name: "Manufacturer Name String",
              id: "manufacturer",
              uuid: "00002a29-0000-1000-8000-00805f9b34fb"
            }
          ]
        },
        {
          name: "Battery Service",
          id: "battery",
          uuid: "0000180f-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "Battery Level",
              id: "level",
              uuid: "00002a19-0000-1000-8000-00805f9b34fb"
            }
          ]
        },
        {
          name: "Nordic Device Firmware Update (DFU) Service",
          id: "dfu",
          uuid: "0000fe59-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "Buttonless DFU",
              id: "dfu",
              uuid: "8ec90003-f315-4f60-9fb8-838830daea50"
            }
          ]
        },
        {
          name: "",
          id: "",
          uuid: "f3641400-00b0-4240-ba50-05ca45bf8abc",
          characteristics: [
            {
              name: "Read + Indicate",
              id: "",
              uuid: "f3641401-00b0-4240-ba50-05ca45bf8abc"
            }
          ]
        },
        {
          name: "Humidity Service",
          id: "humidity",
          uuid: "cf194c6f-d0c1-47b2-aeff-dc610f09bd18",
          characteristics: [
            {
              name: "Humidity Level",
              id: "level",
              uuid: "cf194c70-d0c1-47b2-aeff-dc610f09bd18"
            }
          ]
        },
        {
          name: "Temperature Serivce",
          id: "temperature",
          uuid: "3a90328c-c266-4c76-b05a-6af6104a0b13",
          characteristics: [
            {
              name: "Read",
              id: "level",
              uuid: "3a90328d-c266-4c76-b05a-6af6104a0b13"
            }
          ]
        },
        {
          name: "Forceboard Service",
          id: "forceboard",
          uuid: "9a88d67f-8df2-4afe-9e0d-c2bbbe773dd0",
          characteristics: [
            {
              name: "Write",
              id: "",
              uuid: "9a88d680-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Read + Indicate",
              id: "",
              uuid: "9a88d681-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Read + Notify",
              id: "rx",
              uuid: "9a88d682-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Write",
              id: "",
              uuid: "9a88d683-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Read",
              id: "",
              uuid: "9a88d685-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Write",
              id: "",
              uuid: "9a88d686-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Read + Write",
              id: "",
              uuid: "9a88d687-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Serial / Read + Write",
              id: "",
              uuid: "9a88d688-8df2-4afe-9e0d-c2bbbe773dd0"
            },
            {
              name: "Read + Write",
              id: "",
              uuid: "9a88d689-8df2-4afe-9e0d-c2bbbe773dd0"
            }
          ]
        },
        {
          name: "Weight Serivce",
          id: "weight",
          uuid: "467a8516-6e39-11eb-9439-0242ac130002",
          characteristics: [
            {
              name: "Read + Write",
              id: "tx",
              uuid: "467a8517-6e39-11eb-9439-0242ac130002"
            },
            {
              name: "Read + Write",
              id: "",
              uuid: "467a8518-6e39-11eb-9439-0242ac130002"
            }
          ]
        }
      ],
      commands: {
        STOP_WEIGHT_MEAS: ""
      }
    });
    /**
     * Retrieves battery or voltage information from the device.
     * @returns {Promise<string | undefined>} A Promise that resolves with the battery or voltage information,
     */
    __publicField(this, "battery", async () => {
      return await this.read("battery", "level", 250);
    });
    /**
     * Handles data received from the device, processes weight measurements,
     * and updates mass data including maximum and average values.
     * It also handles command responses for retrieving device information.
     *
     * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.
     */
    __publicField(this, "handleNotifications", (characteristic) => {
      const value = characteristic.value;
      if (value) {
        this.updateTimestamp();
        if (value.buffer) {
          const receivedTime = Date.now();
          const dataArray = new Uint8Array(value.buffer);
          for (let i = 2; i < dataArray.length; i += 3) {
            const receivedData = dataArray[i] << 16 | dataArray[i + 1] << 8 | dataArray[i + 2];
            const convertedReceivedData = receivedData * 0.453592;
            const numericData = convertedReceivedData - this.applyTare(convertedReceivedData);
            this.downloadPackets.push({
              received: receivedTime,
              sampleNum: this.dataPointCount,
              battRaw: 0,
              samples: [convertedReceivedData],
              masses: [numericData]
            });
            this.massMax = Math.max(Number(this.massMax), numericData).toFixed(1);
            const currentMassTotal = Math.max(-1e3, numericData);
            this.massTotalSum += currentMassTotal;
            this.dataPointCount++;
            this.massAverage = (this.massTotalSum / this.dataPointCount).toFixed(1);
            this.activityCheck(numericData);
            this.notifyCallback({
              massMax: this.massMax,
              massAverage: this.massAverage,
              massTotal: Math.max(-1e3, numericData).toFixed(1)
            });
          }
        }
      }
    });
    /**
     * Retrieves humidity level from the device.
     * @returns {Promise<string>} A Promise that resolves with the humidity level,
     */
    __publicField(this, "humidity", async () => {
      return await this.read("humidity", "level", 250);
    });
    /**
     * Retrieves manufacturer information from the device.
     * @returns {Promise<string>} A Promise that resolves with the manufacturer information,
     */
    __publicField(this, "manufacturer", async () => {
      return await this.read("device", "manufacturer", 250);
    });
    /**
     * Stops the data stream on the specified device.
     * @returns {Promise<void>} A promise that resolves when the stream is stopped.
     */
    __publicField(this, "stop", async () => {
      await this.write("weight", "tx", this.commands.STOP_WEIGHT_MEAS, 0);
    });
    /**
     * Starts streaming data from the specified device.
     * @param {number} [duration=0] - The duration of the stream in milliseconds. If set to 0, stream will continue indefinitely.
     * @returns {Promise<void>} A promise that resolves when the streaming operation is completed.
     */
    __publicField(this, "stream", async (duration = 0) => {
      this.downloadPackets.length = 0;
      await this.write("weight", "tx", new Uint8Array([4]), duration);
      if (duration !== 0) {
        await this.stop();
      }
    });
    /**
     * Retrieves temperature information from the device.
     * @returns {Promise<string>} A Promise that resolves with the manufacturer information,
     */
    __publicField(this, "temperature", async () => {
      return await this.read("temperature", "level", 250);
    });
  }
};

// node_modules/@hangtime/grip-connect/dist/models/device/kilterboard.model.js
var KilterBoardPacket;
(function(KilterBoardPacket2) {
  KilterBoardPacket2[KilterBoardPacket2["V2_MIDDLE"] = 77] = "V2_MIDDLE";
  KilterBoardPacket2[KilterBoardPacket2["V2_FIRST"] = 78] = "V2_FIRST";
  KilterBoardPacket2[KilterBoardPacket2["V2_LAST"] = 79] = "V2_LAST";
  KilterBoardPacket2[KilterBoardPacket2["V2_ONLY"] = 80] = "V2_ONLY";
  KilterBoardPacket2[KilterBoardPacket2["V3_MIDDLE"] = 81] = "V3_MIDDLE";
  KilterBoardPacket2[KilterBoardPacket2["V3_FIRST"] = 82] = "V3_FIRST";
  KilterBoardPacket2[KilterBoardPacket2["V3_LAST"] = 83] = "V3_LAST";
  KilterBoardPacket2[KilterBoardPacket2["V3_ONLY"] = 84] = "V3_ONLY";
})(KilterBoardPacket || (KilterBoardPacket = {}));
var KilterBoardPlacementRoles = [
  {
    id: 12,
    product_id: 1,
    position: 1,
    name: "start",
    full_name: "Start",
    led_color: "00FF00",
    screen_color: "00DD00"
  },
  {
    id: 13,
    product_id: 1,
    position: 2,
    name: "middle",
    full_name: "Middle",
    led_color: "00FFFF",
    screen_color: "00FFFF"
  },
  {
    id: 14,
    product_id: 1,
    position: 3,
    name: "finish",
    full_name: "Finish",
    led_color: "FF00FF",
    screen_color: "FF00FF"
  },
  {
    id: 15,
    product_id: 1,
    position: 4,
    name: "foot",
    full_name: "Foot Only",
    led_color: "FFB600",
    screen_color: "FFA500"
  }
];
var _KilterBoard = class _KilterBoard extends Device {
  constructor() {
    super({
      filters: [
        {
          services: [_KilterBoard.AuroraUUID]
        }
      ],
      services: [
        {
          name: "UART Nordic Service",
          id: "uart",
          uuid: "6e400001-b5a3-f393-e0a9-e50e24dcca9e",
          characteristics: [
            {
              name: "TX",
              id: "tx",
              uuid: "6e400002-b5a3-f393-e0a9-e50e24dcca9e"
            }
            // {
            //   name: "RX",
            //   id: "rx",
            //   uuid: "6e400003-b5a3-f393-e0a9-e50e24dcca9e",
            // },
          ]
        }
      ]
    });
    /**
     * The kilter board only supports messages of 20 bytes
     * at a time. This method splits a full message into parts
     * of 20 bytes
     *
     * @param buffer
     */
    __publicField(this, "splitMessages", (buffer) => this.splitEvery(_KilterBoard.maxBluetoothMessageSize, buffer).map((arr) => new Uint8Array(arr)));
    /**
     * Configures the LEDs based on an array of climb placements.
     * @param {{ position: number; role_id: number }[]} config - Array of climb placements for the LEDs.
     * @returns {Promise<number[] | undefined>} A promise that resolves with the payload array for the Kilter Board if LED settings were applied, or `undefined` if no action was taken or for the Motherboard.
     */
    __publicField(this, "led", async (config) => {
      if (Array.isArray(config)) {
        const payload = this.prepBytesV3(config);
        if (this.isConnected()) {
          await this.writeMessageSeries(this.splitMessages(payload));
        }
        return payload;
      }
      return void 0;
    });
  }
  /**
   * Calculates the checksum for a byte array by summing up all bytes ot hre packet in a single-byte variable.
   * @param data - The array of bytes to calculate the checksum for.
   * @returns {number} The calculated checksum value.
   */
  checksum(data) {
    let i = 0;
    for (const value of data) {
      i = i + value & 255;
    }
    return ~i & 255;
  }
  /**
   * Wraps a byte array with header and footer bytes for transmission.
   * @param data - The array of bytes to wrap.
   * @returns {number[]} The wrapped byte array.
   */
  wrapBytes(data) {
    if (data.length > _KilterBoard.messageBodyMaxLength) {
      return [];
    }
    return [1, data.length, this.checksum(data), 2, ...data, 3];
  }
  /**
   * Encodes a position into a byte array.
   * The lowest 8 bits of the position get put in the first byte of the group.
   * The highest 8 bits of the position get put in the second byte of the group.
   * @param position - The position to encode.
   * @returns {number[]} The encoded byte array representing the position.
   */
  encodePosition(position) {
    const position1 = position & 255;
    const position2 = (position & 65280) >> 8;
    return [position1, position2];
  }
  /**
   * Encodes a color string into a numeric representation.
   * The rgb color, 3 bits for the R and G components, 2 bits for the B component, with the 3 R bits occupying the high end of the byte and the 2 B bits in the low end (hence 3 G bits in the middle).
   * @param color - The color string in hexadecimal format (e.g., 'FFFFFF').
   * @returns The encoded /compressed color value.
   */
  encodeColor(color) {
    const substring = color.substring(0, 2);
    const substring2 = color.substring(2, 4);
    const parsedSubstring = parseInt(substring, 16) / 32;
    const parsedSubstring2 = parseInt(substring2, 16) / 32;
    const parsedResult = parsedSubstring << 5 | parsedSubstring2 << 2;
    const substring3 = color.substring(4, 6);
    const parsedSubstring3 = parseInt(substring3, 16) / 64;
    const finalParsedResult = parsedResult | parsedSubstring3;
    return finalParsedResult;
  }
  /**
   * Encodes a placement (requires a 16-bit position and a 24-bit rgb color. ) into a byte array.
   * @param position - The position to encode.
   * @param ledColor - The color of the LED in hexadecimal format (e.g., 'FFFFFF').
   * @returns The encoded byte array representing the placement.
   */
  encodePlacement(position, ledColor) {
    return [...this.encodePosition(position), this.encodeColor(ledColor)];
  }
  /**
   * Prepares byte arrays for transmission based on a list of climb placements.
   * @param {{ position: number; role_id: number }[]} climbPlacementList - The list of climb placements containing position and role ID.
   * @returns {number[]} The final byte array ready for transmission.
   */
  prepBytesV3(climbPlacementList) {
    const resultArray = [];
    let tempArray = [KilterBoardPacket.V3_MIDDLE];
    for (const climbPlacement of climbPlacementList) {
      if (tempArray.length + 3 > _KilterBoard.messageBodyMaxLength) {
        resultArray.push(tempArray);
        tempArray = [KilterBoardPacket.V3_MIDDLE];
      }
      const role = KilterBoardPlacementRoles.find((placement) => placement.id === climbPlacement.role_id);
      if (!role) {
        throw new Error(`Role with id ${climbPlacement.role_id} not found in placement_roles`);
      }
      const encodedPlacement = this.encodePlacement(climbPlacement.position, role.led_color);
      tempArray.push(...encodedPlacement);
    }
    resultArray.push(tempArray);
    if (resultArray.length === 1) {
      resultArray[0][0] = KilterBoardPacket.V3_ONLY;
    } else if (resultArray.length > 1) {
      resultArray[0][0] = KilterBoardPacket.V3_FIRST;
      resultArray[resultArray.length - 1][0] = KilterBoardPacket.V3_LAST;
    }
    const finalResultArray = [];
    for (const currentArray of resultArray) {
      finalResultArray.push(...this.wrapBytes(currentArray));
    }
    return finalResultArray;
  }
  /**
   * Splits a collection into slices of the specified length.
   * https://github.com/ramda/ramda/blob/master/source/splitEvery.js
   * @param {Number} n
   * @param {Array} list
   * @return {Array<number[]>}
   */
  splitEvery(n, list) {
    if (n <= 0) {
      throw new Error("First argument to splitEvery must be a positive integer");
    }
    const result = [];
    let idx = 0;
    while (idx < list.length) {
      result.push(list.slice(idx, idx += n));
    }
    return result;
  }
  /**
   * Sends a series of messages to a device.
   */
  async writeMessageSeries(messages) {
    for (const message of messages) {
      await this.write("uart", "tx", message);
    }
  }
};
/**
 * UUID for the Aurora Climbing Advertising service.
 * This constant is used to identify the specific Bluetooth service for Kilter Boards.
 * @type {string}
 * @static
 * @readonly
 * @constant
 */
__publicField(_KilterBoard, "AuroraUUID", "4488b571-7806-4df6-bcff-a2897e4953ff");
/**
 * Maximum length of the message body for byte wrapping.
 * This value defines the limit for the size of messages that can be sent or received
 * to ensure proper byte wrapping in communication.
 * @type {number}
 * @private
 * @readonly
 * @constant
 */
__publicField(_KilterBoard, "messageBodyMaxLength", 255);
/**
 * Maximum length of the Bluetooth message chunk.
 * This value sets the upper limit for the size of individual Bluetooth messages
 * sent to and from the device to comply with Bluetooth protocol constraints.
 * @type {number}
 * @private
 * @readonly
 * @constant
 */
__publicField(_KilterBoard, "maxBluetoothMessageSize", 20);
var KilterBoard = _KilterBoard;

// node_modules/@hangtime/grip-connect/dist/models/device/motherboard.model.js
var _Motherboard = class _Motherboard extends Device {
  constructor() {
    super({
      filters: [{ name: "Motherboard" }],
      services: [
        {
          name: "Device Information",
          id: "device",
          uuid: "0000180a-0000-1000-8000-00805f9b34fb",
          characteristics: [
            // {
            //     name: 'Serial Number String (Blocked)',
            //     id: 'serial'
            //     uuid: '00002a25-0000-1000-8000-00805f9b34fb'
            // },
            {
              name: "Firmware Revision String",
              id: "firmware",
              uuid: "00002a26-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "Hardware Revision String",
              id: "hardware",
              uuid: "00002a27-0000-1000-8000-00805f9b34fb"
            },
            {
              name: "Manufacturer Name String",
              id: "manufacturer",
              uuid: "00002a29-0000-1000-8000-00805f9b34fb"
            }
          ]
        },
        {
          name: "Battery Service",
          id: "battery",
          uuid: "0000180f-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "Battery Level",
              id: "level",
              uuid: "00002a19-0000-1000-8000-00805f9b34fb"
            }
          ]
        },
        {
          name: "LED Service",
          id: "led",
          uuid: "10ababcd-15e1-28ff-de13-725bea03b127",
          characteristics: [
            {
              name: "Red LED",
              id: "red",
              uuid: "10ab1524-15e1-28ff-de13-725bea03b127"
            },
            {
              name: "Green LED",
              id: "green",
              uuid: "10ab1525-15e1-28ff-de13-725bea03b127"
            }
          ]
        },
        {
          name: "UART Nordic Service",
          id: "uart",
          uuid: "6e400001-b5a3-f393-e0a9-e50e24dcca9e",
          characteristics: [
            {
              name: "TX",
              id: "tx",
              uuid: "6e400002-b5a3-f393-e0a9-e50e24dcca9e"
            },
            {
              name: "RX",
              id: "rx",
              uuid: "6e400003-b5a3-f393-e0a9-e50e24dcca9e"
            }
          ]
        }
      ],
      commands: {
        GET_SERIAL: "#",
        START_WEIGHT_MEAS: "S30",
        STOP_WEIGHT_MEAS: "",
        // All commands will stop the data stream.
        GET_CALIBRATION: "C",
        SLEEP: 0,
        GET_TEXT: "T",
        DEBUG_STREAM: "D"
      }
    });
    /**
     * Buffer to store received data from the device.
     * @type {number[]}
     * @private
     */
    __publicField(this, "receiveBuffer", []);
    /**
     * Calibration data for each sensor of the device.
     * @type {number[][][]}
     * @private
     */
    __publicField(this, "calibrationData", [[], [], [], []]);
    /**
     * Applies calibration to a sample value.
     * @param {number} sample - The sample value to calibrate.
     * @param {number[][]} calibration - The calibration data.
     * @returns {number} The calibrated sample value.
     */
    __publicField(this, "applyCalibration", (sample, calibration) => {
      const zeroCalibration = calibration[0][2];
      let sign = 1;
      let final = 0;
      if (sample < zeroCalibration) {
        sign = -1;
        sample = /* 2 * zeroCalibration */
        -sample;
      }
      for (let i = 1; i < calibration.length; i++) {
        const calibrationStart = calibration[i - 1][2];
        const calibrationEnd = calibration[i][2];
        if (sample < calibrationEnd) {
          final = calibration[i - 1][1] + (sample - calibrationStart) / (calibrationEnd - calibrationStart) * (calibration[i][1] - calibration[i - 1][1]);
          break;
        }
      }
      return sign * final;
    });
    /**
     * Retrieves battery or voltage information from the device.
     * @returns {Promise<string | undefined>} A Promise that resolves with the battery or voltage information,
     */
    __publicField(this, "battery", async () => {
      return await this.read("battery", "level", 250);
    });
    /**
     * Writes a command to get calibration data from the device.
     * @returns {Promise<void>} A Promise that resolves when the command is successfully sent.
     */
    __publicField(this, "calibration", async () => {
      await this.write("uart", "tx", this.commands.GET_CALIBRATION, 2500, (data) => {
        console.log(data);
      });
    });
    /**
     * Retrieves firmware version from the device.
     * @returns {Promise<string>} A Promise that resolves with the firmware version,
     */
    __publicField(this, "firmware", async () => {
      return await this.read("device", "firmware", 250);
    });
    /**
     * Handles data received from the Motherboard device. Processes hex-encoded streaming packets
     * to extract samples, calibrate masses, and update running averages of mass data.
     * If the received data is not a valid hex packet, it returns the unprocessed data.
     *
     * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.
     */
    __publicField(this, "handleNotifications", (characteristic) => {
      const value = characteristic.value;
      if (value) {
        this.updateTimestamp();
        if (value.buffer) {
          for (let i = 0; i < value.byteLength; i++) {
            this.receiveBuffer.push(value.getUint8(i));
          }
          let idx;
          while ((idx = this.receiveBuffer.indexOf(10)) >= 0) {
            const line = this.receiveBuffer.splice(0, idx + 1).slice(0, -1);
            if (line.length > 0 && line[line.length - 1] === 13)
              line.pop();
            const decoder = new TextDecoder("utf-8");
            const receivedData = decoder.decode(new Uint8Array(line));
            const receivedTime = Date.now();
            const isAllHex = /^[0-9A-Fa-f]+$/g.test(receivedData);
            if (isAllHex && receivedData.length === _Motherboard.packetLength) {
              const bytes = Array.from({ length: receivedData.length / 2 }, (_, i) => Number(`0x${receivedData.substring(i * 2, i * 2 + 2)}`));
              const packet = {
                received: receivedTime,
                sampleNum: new DataView(new Uint8Array(bytes).buffer).getUint16(0, true),
                battRaw: new DataView(new Uint8Array(bytes).buffer).getUint16(2, true),
                samples: [],
                masses: []
              };
              const dataView = new DataView(new Uint8Array(bytes).buffer);
              for (let i = 0; i < _Motherboard.samplesNumber; i++) {
                const sampleStart = 4 + 3 * i;
                const rawValue = dataView.getUint8(sampleStart) | dataView.getUint8(sampleStart + 1) << 8 | dataView.getUint8(sampleStart + 2) << 16;
                packet.samples[i] = rawValue >>> 0;
                if (packet.samples[i] >= 8388607) {
                  packet.samples[i] -= 16777216;
                }
                packet.masses[i] = this.applyCalibration(packet.samples[i], this.calibrationData[i]);
              }
              packet.masses[1] *= -1;
              packet.masses[2] *= -1;
              this.downloadPackets.push({
                received: packet.received,
                sampleNum: packet.battRaw,
                battRaw: packet.received,
                samples: [...packet.samples],
                masses: [...packet.masses]
              });
              let left = packet.masses[0];
              let center = packet.masses[1];
              let right = packet.masses[2];
              left -= this.applyTare(left);
              center -= this.applyTare(center);
              right -= this.applyTare(right);
              this.massMax = Math.max(Number(this.massMax), Math.max(-1e3, left + center + right)).toFixed(1);
              const currentMassTotal = Math.max(-1e3, left + center + right);
              this.massTotalSum += currentMassTotal;
              this.dataPointCount++;
              this.massAverage = (this.massTotalSum / this.dataPointCount).toFixed(1);
              this.activityCheck(center);
              this.notifyCallback({
                massTotal: Math.max(-1e3, left + center + right).toFixed(1),
                massMax: this.massMax,
                massAverage: this.massAverage,
                massLeft: Math.max(-1e3, packet.masses[0]).toFixed(1),
                massCenter: Math.max(-1e3, packet.masses[1]).toFixed(1),
                massRight: Math.max(-1e3, packet.masses[2]).toFixed(1)
              });
            } else if (this.writeLast === this.commands.GET_CALIBRATION) {
              if ((receivedData.match(/,/g) || []).length === 3) {
                const parts = receivedData.split(",");
                const numericParts = parts.map((x) => parseFloat(x));
                this.calibrationData[numericParts[0]].push(numericParts.slice(1));
              }
            } else {
              this.writeCallback(receivedData);
            }
          }
        }
      }
    });
    /**
     * Retrieves hardware version from the device.
     * @returns {Promise<string>} A Promise that resolves with the hardware version,
     */
    __publicField(this, "hardware", async () => {
      return await this.read("device", "hardware", 250);
    });
    /**
     * Sets the LED color based on a single color option. Defaults to turning the LEDs off if no configuration is provided.
     * @param {"green" | "red" | "orange"} [config] - Optional color or array of climb placements for the LEDs. Ignored if placements are provided.
     * @returns {Promise<number[] | undefined>} A promise that resolves with the payload array for the Kilter Board if LED settings were applied, or `undefined` if no action was taken or for the Motherboard.
     */
    __publicField(this, "led", async (config) => {
      if (this.isConnected()) {
        const colorMapping = {
          green: [[0], [1]],
          red: [[1], [0]],
          orange: [[1], [1]],
          off: [[0], [0]]
        };
        const color = typeof config === "string" && colorMapping[config] ? config : "off";
        const [redValue, greenValue] = colorMapping[color];
        await this.write("led", "red", new Uint8Array(redValue));
        await this.write("led", "green", new Uint8Array(greenValue), 1250);
      }
      return void 0;
    });
    /**
     * Retrieves manufacturer information from the device.
     * @returns {Promise<string>} A Promise that resolves with the manufacturer information,
     */
    __publicField(this, "manufacturer", async () => {
      return await this.read("device", "manufacturer", 250);
    });
    /**
     * Retrieves serial number from the device.
     * @returns {Promise<string>} A Promise that resolves with the serial number,
     */
    __publicField(this, "serial", async () => {
      let response = void 0;
      await this.write("uart", "tx", this.commands.GET_SERIAL, 250, (data) => {
        response = data;
      });
      return response;
    });
    /**
     * Stops the data stream on the specified device.
     * @returns {Promise<void>} A promise that resolves when the stream is stopped.
     */
    __publicField(this, "stop", async () => {
      await this.write("uart", "tx", this.commands.STOP_WEIGHT_MEAS, 0);
    });
    /**
     * Starts streaming data from the specified device.
     * @param {number} [duration=0] - The duration of the stream in milliseconds. If set to 0, stream will continue indefinitely.
     * @returns {Promise<void>} A promise that resolves when the streaming operation is completed.
     */
    __publicField(this, "stream", async (duration = 0) => {
      this.downloadPackets.length = 0;
      if (!this.calibrationData[0].length) {
        await this.calibration();
      }
      await this.write("uart", "tx", this.commands.START_WEIGHT_MEAS, duration);
      if (duration !== 0) {
        await this.stop();
      }
    });
    /**
     * Retrieves the entire 320 bytes of non-volatile memory from the device.
     *
     * The memory consists of 10 segments, each 32 bytes long. If any segment was previously written,
     * the corresponding data will appear in the response. Unused portions of the memory are
     * padded with whitespace.
     *
     * @returns {Promise<string>} A Promise that resolves with the 320-byte memory content as a string,
     */
    __publicField(this, "text", async () => {
      let response = void 0;
      await this.write("uart", "tx", this.commands.GET_TEXT, 250, (data) => {
        response = data;
      });
      return response;
    });
  }
};
/**
 * Length of the packet received from the device.
 * @type {number}
 * @static
 * @readonly
 * @constant
 */
__publicField(_Motherboard, "packetLength", 32);
/**
 * Number of samples contained in the data packet.
 * @type {number}
 * @static
 * @readonly
 * @constant
 */
__publicField(_Motherboard, "samplesNumber", 3);
var Motherboard = _Motherboard;

// node_modules/@hangtime/grip-connect/dist/models/device/mysmartboard.model.js
var mySmartBoard = class extends Device {
  constructor() {
    super({
      filters: [{ name: "mySmartBoard" }],
      services: []
    });
  }
};

// node_modules/@hangtime/grip-connect/dist/models/device/progressor.model.js
var ProgressorResponses;
(function(ProgressorResponses2) {
  ProgressorResponses2[ProgressorResponses2["COMMAND_RESPONSE"] = 0] = "COMMAND_RESPONSE";
  ProgressorResponses2[ProgressorResponses2["WEIGHT_MEASURE"] = 1] = "WEIGHT_MEASURE";
  ProgressorResponses2[ProgressorResponses2["PEAK_RFD_MEAS"] = 2] = "PEAK_RFD_MEAS";
  ProgressorResponses2[ProgressorResponses2["PEAK_RFD_MEAS_SERIES"] = 3] = "PEAK_RFD_MEAS_SERIES";
  ProgressorResponses2[ProgressorResponses2["LOW_BATTERY_WARNING"] = 4] = "LOW_BATTERY_WARNING";
})(ProgressorResponses || (ProgressorResponses = {}));
var Progressor = class extends Device {
  constructor() {
    super({
      filters: [{ namePrefix: "Progressor" }],
      services: [
        {
          name: "Progressor Service",
          id: "progressor",
          uuid: "7e4e1701-1ea6-40c9-9dcc-13d34ffead57",
          characteristics: [
            {
              name: "Notify",
              id: "rx",
              uuid: "7e4e1702-1ea6-40c9-9dcc-13d34ffead57"
            },
            {
              name: "Write",
              id: "tx",
              uuid: "7e4e1703-1ea6-40c9-9dcc-13d34ffead57"
            }
          ]
        },
        {
          name: "Nordic Device Firmware Update (DFU) Service",
          id: "dfu",
          uuid: "0000fe59-0000-1000-8000-00805f9b34fb",
          characteristics: [
            {
              name: "Buttonless DFU",
              id: "dfu",
              uuid: "8ec90003-f315-4f60-9fb8-838830daea50"
            }
          ]
        }
      ],
      commands: {
        TARE_SCALE: "d",
        // 0x64
        START_WEIGHT_MEAS: "e",
        // 0x65
        STOP_WEIGHT_MEAS: "f",
        // 0x66
        START_PEAK_RFD_MEAS: "g",
        //  0x67
        START_PEAK_RFD_MEAS_SERIES: "h",
        //  0x68
        ADD_CALIB_POINT: "i",
        //  0x69
        SAVE_CALIB: "j",
        //  0x6a
        GET_FW_VERSION: "k",
        //  0x6b
        GET_ERR_INFO: "l",
        //  0x6c
        CLR_ERR_INFO: "m",
        //  0x6d
        SLEEP: "n",
        // 0x6e
        GET_BATT_VLTG: "o"
        //  0x6f
      }
    });
    /**
     * Retrieves battery or voltage information from the device.
     * @returns {Promise<string | undefined>} A Promise that resolves with the battery or voltage information,
     */
    __publicField(this, "battery", async () => {
      let response = void 0;
      await this.write("progressor", "tx", this.commands.GET_BATT_VLTG, 250, (data) => {
        response = data;
      });
      return response;
    });
    /**
     * Retrieves firmware version from the device.
     * @returns {Promise<string>} A Promise that resolves with the firmware version,
     */
    __publicField(this, "firmware", async () => {
      let response = void 0;
      await this.write("progressor", "tx", this.commands.GET_FW_VERSION, 250, (data) => {
        response = data;
      });
      return response;
    });
    /**
     * Handles data received from the device, processes weight measurements,
     * and updates mass data including maximum and average values.
     * It also handles command responses for retrieving device information.
     *
     * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.
     */
    __publicField(this, "handleNotifications", (characteristic) => {
      const value = characteristic.value;
      if (value) {
        this.updateTimestamp();
        if (value.buffer) {
          const receivedTime = Date.now();
          const kind = value.getInt8(0);
          if (kind === ProgressorResponses.WEIGHT_MEASURE) {
            let offset = 2;
            while (offset < value.byteLength) {
              const weight = value.getFloat32(offset, true);
              offset += 4;
              const seconds = value.getInt32(offset, true);
              offset += 4;
              if (!isNaN(weight) && !isNaN(seconds)) {
                const numericData = weight - this.applyTare(weight);
                this.downloadPackets.push({
                  received: receivedTime,
                  sampleNum: seconds,
                  battRaw: 0,
                  samples: [weight],
                  masses: [numericData]
                });
                this.massMax = Math.max(Number(this.massMax), Number(numericData)).toFixed(1);
                const currentMassTotal = Math.max(-1e3, Number(numericData));
                this.massTotalSum += currentMassTotal;
                this.dataPointCount++;
                this.massAverage = (this.massTotalSum / this.dataPointCount).toFixed(1);
                this.activityCheck(numericData);
                this.notifyCallback({
                  massMax: this.massMax,
                  massAverage: this.massAverage,
                  massTotal: Math.max(-1e3, numericData).toFixed(1)
                });
              }
            }
          } else if (kind === ProgressorResponses.COMMAND_RESPONSE) {
            if (!this.writeLast)
              return;
            let output = "";
            if (this.writeLast === this.commands.GET_BATT_VLTG) {
              output = new DataView(value.buffer, 2).getUint32(0, true).toString();
            } else if (this.writeLast === this.commands.GET_FW_VERSION) {
              output = new TextDecoder().decode(new Uint8Array(value.buffer).slice(2));
            } else if (this.writeLast === this.commands.GET_ERR_INFO) {
              output = new TextDecoder().decode(new Uint8Array(value.buffer.slice(2)));
            }
            this.writeCallback(output);
          } else if (kind === ProgressorResponses.LOW_BATTERY_WARNING) {
            console.warn("⚠️ Low power detected. Please consider connecting to a power source.");
          } else {
            throw new Error(`Unknown message kind detected: ${kind}`);
          }
        }
      }
    });
    /**
     * Stops the data stream on the specified device.
     * @returns {Promise<void>} A promise that resolves when the stream is stopped.
     */
    __publicField(this, "stop", async () => {
      await this.write("progressor", "tx", this.commands.STOP_WEIGHT_MEAS, 0);
    });
    /**
     * Starts streaming data from the specified device.
     * @param {number} [duration=0] - The duration of the stream in milliseconds. If set to 0, stream will continue indefinitely.
     * @returns {Promise<void>} A promise that resolves when the streaming operation is completed.
     */
    __publicField(this, "stream", async (duration = 0) => {
      this.downloadPackets.length = 0;
      await this.write("progressor", "tx", this.commands.START_WEIGHT_MEAS, duration);
      if (duration !== 0) {
        await this.stop();
      }
    });
  }
};

// node_modules/@hangtime/grip-connect/dist/models/device/wh-c06.model.js
var _WHC06 = class _WHC06 extends Device {
  // /**
  //  * Offset for the byte location in the manufacturer data to determine weight stability.
  //  * @type {number}
  //  * @static
  //  * @readonly
  //  * @constant
  //  */
  // private static readonly stableOffset: number = 14
  constructor() {
    super({
      filters: [
        {
          // namePrefix: "IF_B7",
          manufacturerData: [
            {
              companyIdentifier: 256
              // 256
            }
          ]
        }
      ],
      services: []
    });
    /**
     * To track disconnection timeout.
     * @type {number|null}
     * @private
     */
    __publicField(this, "advertisementTimeout", null);
    /**
     * The limit in seconds when timeout is triggered
     * @type {number}
     * @private
     * @readonly
     */
    __publicField(this, "advertisementTimeoutTime", 10);
    /**
     * Connects to a Bluetooth device.
     * @param {Function} [onSuccess] - Optional callback function to execute on successful connection. Default logs success.
     * @param {Function} [onError] - Optional callback function to execute on error. Default logs the error.
     */
    __publicField(this, "connect", async (onSuccess = () => console.log("Connected successfully"), onError = (error) => console.error(error)) => {
      try {
        const optionalManufacturerData = this.filters.flatMap((filter) => {
          var _a;
          return ((_a = filter.manufacturerData) == null ? void 0 : _a.map((data) => data.companyIdentifier)) || [];
        });
        const bluetooth = await this.getBluetooth();
        this.bluetooth = await bluetooth.requestDevice({
          filters: this.filters,
          optionalManufacturerData
        });
        if (!this.bluetooth.gatt) {
          throw new Error("GATT is not available on this device");
        }
        this.updateTimestamp();
        onSuccess();
        this.bluetooth.addEventListener("advertisementreceived", (event) => {
          const data = event.manufacturerData.get(_WHC06.manufacturerId);
          if (data) {
            const weight = data.getUint8(_WHC06.weightOffset) << 8 | data.getUint8(_WHC06.weightOffset + 1);
            const receivedTime = Date.now();
            const receivedData = weight / 100;
            const numericData = receivedData - this.applyTare(receivedData) * -1;
            this.downloadPackets.push({
              received: receivedTime,
              sampleNum: this.dataPointCount,
              battRaw: 0,
              samples: [numericData],
              masses: [numericData]
            });
            this.massMax = Math.max(Number(this.massMax), numericData).toFixed(1);
            const currentMassTotal = Math.max(-1e3, numericData);
            this.massTotalSum += currentMassTotal;
            this.dataPointCount++;
            this.massAverage = (this.massTotalSum / this.dataPointCount).toFixed(1);
            this.activityCheck(numericData);
            this.notifyCallback({
              massMax: this.massMax,
              massAverage: this.massAverage,
              massTotal: Math.max(-1e3, numericData).toFixed(1)
            });
          }
          this.resetAdvertisementTimeout();
        });
        if (optionalManufacturerData.length) {
          if (typeof this.bluetooth.watchAdvertisements === "function") {
            await this.bluetooth.watchAdvertisements();
          } else {
            throw new Error("watchAdvertisements isn't supported. For Chrome, enable it at chrome://flags/#enable-experimental-web-platform-features.");
          }
        }
      } catch (error) {
        onError(error);
      }
    });
    /**
     * Custom check if a Bluetooth device is connected.
     * For the WH-C06 device, the `gatt.connected` property remains `false` even after the device is connected.
     * @returns {boolean} A boolean indicating whether the device is connected.
     */
    __publicField(this, "isConnected", () => {
      return !!this.bluetooth;
    });
    /**
     * Resets the timeout that checks if the device is still advertising.
     */
    __publicField(this, "resetAdvertisementTimeout", () => {
      if (this.advertisementTimeout) {
        clearTimeout(this.advertisementTimeout);
      }
      this.advertisementTimeout = globalThis.setTimeout(() => {
        const disconnectedEvent = new Event("gattserverdisconnected");
        Object.defineProperty(disconnectedEvent, "target", {
          value: this.bluetooth,
          writable: false
        });
        console.error(`No advertisement received for ${this.advertisementTimeoutTime} seconds, stopping tracking..`);
        this.onDisconnected(disconnectedEvent);
      }, this.advertisementTimeoutTime * 1e3);
    });
  }
};
/**
 * Offset for the byte location in the manufacturer data to extract the weight.
 * @type {number}
 * @static
 * @readonly
 * @constant
 */
__publicField(_WHC06, "weightOffset", 10);
/**
 * Company identifier for WH-C06, also used by 'TomTom International BV': https://www.bluetooth.com/specifications/assigned-numbers/
 * @type {number}
 * @static
 * @readonly
 * @constant
 */
__publicField(_WHC06, "manufacturerId", 256);
var WHC06 = _WHC06;
export {
  Climbro,
  Entralpi,
  ForceBoard,
  KilterBoard,
  Motherboard,
  Progressor,
  WHC06,
  mySmartBoard
};
//# sourceMappingURL=@hangtime_grip-connect.js.map
